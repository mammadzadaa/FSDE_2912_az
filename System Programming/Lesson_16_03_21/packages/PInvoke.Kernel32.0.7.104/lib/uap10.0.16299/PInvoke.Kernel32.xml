<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PInvoke.Kernel32</name>
    </assembly>
    <members>
        <member name="T:PInvoke.Kernel32">
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.APP_MEMORY_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateFileFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreateProcessFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.CreationDisposition"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ErrorModes"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileAccess"/> nested type.
            </content>
            <content>
            Contains the nested <see cref="T:PInvoke.Kernel32.FileAttribute"/> type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileShare"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FileSystemFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FILETIME"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FindFirstFileExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.FormatMessageFlags"/> nested type.
            </content>
            <content>
            Contains the nested <see cref="T:PInvoke.Kernel32.HandleFlags"/> type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.MemoryPriority"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.MEMORY_PRIORITY_INFORMATION"/> nested type.
            </content>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.OSPlatformId"/> nested type.
            </summary>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.OSVERSIONINFO"/> nested type.
            </summary>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> nested type.
            </summary>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.OS_TYPE"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.OVERLAPPED"/> nested type.
            </content>
            <content>Contains the <see cref="T:PInvoke.Kernel32.ProcessAccess" /> nested type.</content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ProcessLeapSecondInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ProcessorArchitecture"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ProcessorPowerThrottlingFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ProcessorType"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESSOR_NUMBER"/> nested type.
            </content>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.ProcessPriorityClass"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.ProcessProtectionLevel"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO"/> nested type.
            </content>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_TYPE"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.PROCESS_PROTECTION_LEVEL_INFORMATION"/> nested type.
            </content>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.PRODUCT_SUITE"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.SYSTEM_INFO"/> nested type.
            </content>
            <content>Contains the <see cref="T:PInvoke.Kernel32.ThreadAccess" /> nested type.</content>
            <summary>
            Contains the nested type <see cref="T:PInvoke.Kernel32.VER_CONDITION"/>.
            </summary>
            <summary>
            Contains the <see cref="T:PInvoke.Kernel32.VER_MASK"/> nested type.
            </summary>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WaitForSingleObjectResult"/> nested type.
            </content>
            <content>
            Contains the <see cref="T:PInvoke.Kernel32.WIN32_FIND_DATA"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ACCESS_MASK"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.APP_MEMORY_INFORMATION"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreateFileFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreateProcessFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.CreationDisposition"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ErrorModes"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FileAccess"/> nested type.
            </content>
            <content>
            Contains the nested <see cref = "T:PInvoke.Kernel32.FileAttribute"/> type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FileShare"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FileSystemFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FILETIME"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FindFirstFileExFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.FormatMessageFlags"/> nested type.
            </content>
            <content>
            Contains the nested <see cref = "T:PInvoke.Kernel32.HandleFlags"/> type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.MemoryPriority"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.MEMORY_PRIORITY_INFORMATION"/> nested type.
            </content>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.OSPlatformId"/> nested type.
            </summary>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.OSVERSIONINFO"/> nested type.
            </summary>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.OSVERSIONINFOEX"/> nested type.
            </summary>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.OS_TYPE"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.OVERLAPPED"/> nested type.
            </content>
            <content>Contains the <see cref = "T:PInvoke.Kernel32.ProcessAccess"/> nested type.</content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ProcessLeapSecondInfoFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ProcessorArchitecture"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ProcessorPowerThrottlingFlags"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ProcessorType"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESSOR_NUMBER"/> nested type.
            </content>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.ProcessPriorityClass"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.ProcessProtectionLevel"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO"/> nested type.
            </content>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_TYPE"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.PROCESS_PROTECTION_LEVEL_INFORMATION"/> nested type.
            </content>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.PRODUCT_SUITE"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeFindFilesHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SafeObjectHandle"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SYSTEMTIME"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.SYSTEM_INFO"/> nested type.
            </content>
            <content>Contains the <see cref = "T:PInvoke.Kernel32.ThreadAccess"/> nested type.</content>
            <summary>
            Contains the nested type <see cref = "T:PInvoke.Kernel32.VER_CONDITION"/>.
            </summary>
            <summary>
            Contains the <see cref = "T:PInvoke.Kernel32.VER_MASK"/> nested type.
            </summary>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.WaitForSingleObjectResult"/> nested type.
            </content>
            <content>
            Contains the <see cref = "T:PInvoke.Kernel32.WIN32_FIND_DATA"/> nested type.
            </content>
            <summary>
            Exported functions from the Kernel32.dll Windows library.
            </summary>
            <content>
            Methods and nested types that are not strictly P/Invokes but provide
            a slightly higher level of functionality to ease calling into native code.
            </content>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            The ACCESS_MASK type is a bitmask that specifies a set of access rights in the access mask of an access control entry.
            </summary>
            <remarks>
            Quite well described here: http://blogs.msdn.com/b/openspecification/archive/2010/04/01/about-the-access-mask-structure.aspx.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.GenericRightsMask">
            <summary>
            Bits 28-31.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRightsMask">
            <summary>
            Bits 24-27.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRightsMask">
            <summary>
            Bits 16-23.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRightsMask">
            <summary>
            Bits 0-15.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> struct.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.ACCESS_SYSTEM_SECURITY">
            <summary>
            It is used to indicate access to a system access control list (SACL). This type of access requires the calling process to have the SE_SECURITY_NAME (Manage auditing and security log) privilege. If this flag is set in the access mask of an audit access ACE (successful or unsuccessful access), the SACL access will be audited.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecialRight.MAXIMUM_ALLOWED">
            <summary>
            Maximum allowed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight">
            <summary>
            Contains the object's standard access rights.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.DELETE">
            <summary>
            Delete access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL">
            <summary>
            Read access to the owner, group, and discretionary access control list (DACL) of the security descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_DAC">
            <summary>
            Write access to the DACL.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.WRITE_OWNER">
            <summary>
            Write access to owner.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.SYNCHRONIZE">
            <summary>
            Synchronize access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_READ">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_WRITE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.STANDARD_RIGHTS_EXECUTE">
            <summary>
            See also <see cref="F:PInvoke.Kernel32.ACCESS_MASK.StandardRight.READ_CONTROL"/>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight">
            <summary>
            Contains the access mask specific to the object type associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.SpecificRight.SPECIFIC_RIGHTS_ALL">
            <summary>
            The bit mask that covers specific rights.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.DesktopGenericRight">
            <summary>
            The following are the generic access rights for a desktop object contained in the interactive window station of the user's logon session.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight">
            <summary>
            Contains the access mask specific to the Desktop associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_ALL_ACCESS">
            <summary>
            The bit mask that covers all possible access rights for the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEMENU">
            <summary>
            Required to create a menu on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_ENUMERATE">
            <summary>
            Required for the desktop to be enumerated.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_HOOKCONTROL">
            <summary>
            Required to establish any of the window hooks.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_JOURNALPLAYBACK">
            <summary>
            Required to perform journal playback on a desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_JOURNALRECORD">
            <summary>
            Required to perform journal recording on a desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_READOBJECTS">
            <summary>
            Required to read objects on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_CREATEWINDOW">
            <summary>
            Required to create a window on the desktop.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_SWITCHDESKTOP">
            <summary>
            Required to activate the desktop using the SwitchDesktop function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRight.DESKTOP_WRITEOBJECTS">
            <summary>
            Required to write objects on the desktop.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.InteractiveWindowStationGenericRight">
            <summary>
            Generic access rights for the interactive window station object, which is the window station assigned to the logon session of the interactive user.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.NonInteractiveWindowStationGenericRight">
            <summary>
            Generic access rights for a noninteractive window station object.
            The system assigns noninteractive window stations to all logon sessions other than that of the interactive user.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight">
            <summary>
            Contains the access mask specific to the Window Station associated with the mask.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ALL_ACCESS">
            <summary>
            The bit mask that covers all possible access rights for the window station.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ACCESSCLIPBOARD">
            <summary>
            Required to use the clipboard.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ACCESSGLOBALATOMS">
            <summary>
            Required to manipulate global atoms.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_CREATEDESKTOP">
            <summary>
            Required to create new desktop objects on the window station.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ENUMDESKTOPS">
            <summary>
            Required to enumerate existing desktop objects.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_ENUMERATE">
            <summary>
            Required for the window station to be enumerated.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_EXITWINDOWS">
            <summary>
            Required to successfully call the ExitWindows or ExitWindowsEx function
            Window stations can be shared by users and this access type can prevent other users of a window station from logging off the window station owner.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_READATTRIBUTES">
            <summary>
            Required to read the attributes of a window station object. This attribute includes color settings and other global window station properties.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_READSCREEN">
            <summary>
            Required to access screen contents.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRight.WINSTA_WRITEATTRIBUTES">
            <summary>
            Required to modify the attributes of a window station object. The attributes include color settings and other global window station properties.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.Value">
            <summary>
            Gets the ACCESS_MASK as a 32-bit unsigned integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.AsInt32">
            <summary>
            Gets the ACCESS_MASK as a 32-bit signed integer.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.GenericRights">
            <summary>
            Gets the generic rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecialRights">
            <summary>
            Gets the special rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.StandardRights">
            <summary>
            Gets the standard rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights">
            <summary>
            Gets the specific rights of this value.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.DesktopSpecificRights">
            <summary>
            Gets the specific rights of this value for desktops.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.InteractiveWindowStationGenericRights">
            <summary>
            Gets the generic rights of this value for interactive window stations.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.NonInteractiveWindowStationGenericRights">
            <summary>
            Gets the generic rights of this value for noninteractive window stations.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.ACCESS_MASK.WindowStationSpecificRights">
            <summary>
            Gets the specific rights of this value for window stations.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.Int32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.Int32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Explicit(PInvoke.Kernel32.ACCESS_MASK)~System.Int32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.Int32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(System.UInt32)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts an <see cref="T:System.UInt32"/> into an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK)~System.UInt32">
            <summary>
            Converts an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/> into an <see cref="T:System.UInt32"/>.
            </summary>
            <param name="value">The value of the ACCESS_MASK.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.StandardRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.StandardRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.GenericRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.GenericRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.op_Implicit(PInvoke.Kernel32.ACCESS_MASK.SpecificRight)~PInvoke.Kernel32.ACCESS_MASK">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.ACCESS_MASK.SpecificRight"/> to an <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.
            </summary>
            <param name="value">The value for the <see cref="T:PInvoke.Kernel32.ACCESS_MASK"/>.</param>
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.CompareTo(PInvoke.Kernel32.ACCESS_MASK)">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.ACCESS_MASK.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.APP_MEMORY_INFORMATION">
            <summary>
            Represents app memory usage at a single point in time.
            This structure can used by in <see cref="M:PInvoke.Kernel32.GetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.Void*,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.APP_MEMORY_INFORMATION.AvailableCommit">
            <summary>
            Total commit available to the app.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.APP_MEMORY_INFORMATION.PrivateCommitUsage">
            <summary>
            The app's usage of private commit.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.APP_MEMORY_INFORMATION.PeakPrivateCommitUsage">
            <summary>
            The app's peak usage of private commit.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.APP_MEMORY_INFORMATION.TotalCommitUsage">
            <summary>
            The app's total usage of private plus shared commit.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreateFileFlags">
            <summary>
            File attributes, flags, and security settings that are passed to the CreateFile method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_BACKUP_SEMANTICS">
            <summary>
                The file is being opened or created for a backup or restore operation. The system ensures that the calling
                process overrides file security checks when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges. For more
                information, see Changing Privileges in a Token. You must set this flag to obtain a handle to a directory. A
                directory handle can be passed to some functions instead of a file handle. For more information, see the Remarks
                section.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_DELETE_ON_CLOSE">
            <summary>
                The file is to be deleted immediately after all of its handles are closed, which includes the specified handle
                and any other open or duplicated handles. If there are existing open handles to a file, the call fails unless they
                were all opened with the <see cref="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE" /> share mode. Subsequent open requests for the
                file fail, unless the <see cref="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE" /> share mode is specified.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING">
            <summary>
                The file or device is being opened with no system caching for data reads and writes. This flag does not affect
                hard disk caching or memory mapped files. There are strict requirements for successfully working with files opened
                with CreateFile using the <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" /> flag.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OPEN_NO_RECALL">
            <summary>
                The file data is requested, but it should continue to be located in remote storage. It should not be
                transported back to local storage. This flag is for use by remote storage systems.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OPEN_REPARSE_POINT">
            <summary>
                Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point. When a file
                is opened, a file handle is returned, whether or not the filter that controls the reparse point is operational.
                This flag cannot be used with the <see cref="F:PInvoke.Kernel32.CreationDisposition.CREATE_ALWAYS" /> flag. If the file is not a
                reparse point, then this flag is ignored. For more information, see the Remarks section.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED">
            <summary>
                The file or device is being opened or created for asynchronous I/O. When subsequent I/O operations are
                completed on this handle, the event specified in the OVERLAPPED structure will be set to the signaled state. If
                this flag is specified, the file can be used for simultaneous read and write operations. If this flag is not
                specified, then I/O operations are serialized, even if the calls to the read and write functions specify an
                OVERLAPPED structure.For information about considerations when using a file handle created with this flag, see the
                Synchronous and Asynchronous I/O Handles section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_POSIX_SEMANTICS">
            <summary>
                Access will occur according to POSIX rules. This includes allowing multiple files with names, differing only
                in case, for file systems that support that naming. Use care when using this option, because files created with
                this flag may not be accessible by applications that are written for MS-DOS or 16-bit Windows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_RANDOM_ACCESS">
            <summary>
                Access is intended to be random. The system can use this as a hint to optimize file caching. This flag has no
                effect if the file system does not support cached I/O and <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" />. For more
                information, see the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_SESSION_AWARE">
            <summary>
                The file or device is being opened with session awareness. If this flag is not specified, then per-session
                devices (such as a redirected USB device) cannot be opened by processes running in session 0. This flag has no
                effect for callers not in session 0. This flag is supported only on server editions of Windows.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_SEQUENTIAL_SCAN">
            <summary>
                Access is intended to be sequential from beginning to end. The system can use this as a hint to optimize file
                caching. This flag should not be used if read-behind (that is, reverse scans) will be used. This flag has no effect
                if the file system does not support cached I/O and <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_NO_BUFFERING" />. For more information, see
                the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_WRITE_THROUGH">
            <summary>
                Write operations will not go through any intermediate cache, they will go directly to disk. For additional
                information, see the Caching Behavior section of this topic.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_SQOS_PRESENT">
            <summary>When this flag is present, one or more other flags ending with Security may also be specified.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_ANONYMOUS">
            <summary>Impersonates a client at the Anonymous impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_CONTEXT_TRACKING">
            <summary>The security tracking mode is dynamic. If this flag is not specified, the security tracking mode is static.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_DELEGATION">
            <summary>Impersonates a client at the Delegation impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_EFFECTIVE_ONLY">
            <summary>
                Only the enabled aspects of the client's security context are available to the server. If you do not specify
                this flag, all aspects of the client's security context are available. This allows the client to limit the groups
                and privileges that a server can use while impersonating the client.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_IDENTIFICATION">
            <summary>Impersonates a client at the Identification impersonation level.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_IMPERSONATION">
            <summary>
                Impersonate a client at the impersonation level. This is the default behavior if no other flags are specified
                along with the <see cref="F:PInvoke.Kernel32.CreateFileFlags.SECURITY_SQOS_PRESENT" /> flag.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreateProcessFlags">
            <summary>
            Flags that may be passed to the CreateProcess function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_BREAKAWAY_FROM_JOB">
            <summary>
            The child processes of a process associated with a job are not associated with the job.
            If the calling process is not associated with a job, this constant has no effect. If the calling process is associated with a job, the job must set the JOB_OBJECT_LIMIT_BREAKAWAY_OK limit.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_DEFAULT_ERROR_MODE">
            <summary>
            The new process does not inherit the error mode of the calling process. Instead, the new process gets the default error mode.
            This feature is particularly useful for multithreaded shell applications that run with hard errors disabled.
            The default behavior is for the new process to inherit the error mode of the caller. Setting this flag changes that default behavior.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE">
            <summary>
            The new process has a new console, instead of inheriting its parent's console (the default). For more information, see Creation of a Console.
            This flag cannot be used with DETACHED_PROCESS.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_PROCESS_GROUP">
            <summary>
            The new process is the root process of a new process group. The process group includes all processes that are descendants of this root process. The process identifier of the new process group is the same as the process identifier, which is returned in the lpProcessInformation parameter. Process groups are used by the GenerateConsoleCtrlEvent function to enable sending a CTRL+BREAK signal to a group of console processes.
            If this flag is specified, CTRL+C signals will be disabled for all processes within the new process group.
            This flag is ignored if specified with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NO_WINDOW">
            <summary>
            The process is a console application that is being run without a console window. Therefore, the console handle for the application is not set.
            This flag is ignored if the application is not a console application, or if it is used with either <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/> or <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DETACHED_PROCESS"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_PROTECTED_PROCESS">
            <summary>
            The process is to be run as a protected process. The system restricts access to protected processes and the threads of protected processes. For more information on how processes can interact with protected processes, see Process Security and Access Rights.
            To activate a protected process, the binary must have a special signature. This signature is provided by Microsoft but not currently available for non-Microsoft binaries. There are currently four protected processes: media foundation, audio engine, Windows error reporting, and system. Components that load into these binaries must also be signed. Multimedia companies can leverage the first two protected processes. For more information, see Overview of the Protected Media Path.
            Windows Server 2003 and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_PRESERVE_CODE_AUTHZ_LEVEL">
            <summary>
            Allows the caller to execute a child process that bypasses the process restrictions that would normally be applied automatically to the process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SEPARATE_WOW_VDM">
            <summary>
            This flag is valid only when starting a 16-bit Windows-based application. If set, the new process runs in a private Virtual DOS Machine (VDM). By default, all 16-bit Windows-based applications run as threads in a single, shared VDM. The advantage of running separately is that a crash only terminates the single VDM; any other programs running in distinct VDMs continue to function normally. Also, 16-bit Windows-based applications that are run in separate VDMs have separate input queues. That means that if one application stops responding momentarily, applications in separate VDMs continue to receive input. The disadvantage of running separately is that it takes significantly more memory to do so. You should use this flag only if the user requests that 16-bit applications should run in their own VDM.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SHARED_WOW_VDM">
            <summary>
            The flag is valid only when starting a 16-bit Windows-based application. If the DefaultSeparateVDM switch in the Windows section of WIN.INI is TRUE, this flag overrides the switch. The new process is run in the shared Virtual DOS Machine.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_SUSPENDED">
            <summary>
            The primary thread of the new process is created in a suspended state, and does not run until the <see cref="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)"/> function is called.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_UNICODE_ENVIRONMENT">
            <summary>
            If this flag is set, the environment block pointed to by lpEnvironment uses Unicode characters. Otherwise, the environment block uses ANSI characters.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_ONLY_THIS_PROCESS">
            <summary>
            The calling thread starts and debugs the new process. It can receive all related debug events using the WaitForDebugEvent function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS">
            <summary>
            The calling thread starts and debugs the new process and all child processes created by the new process. It can receive all related debug events using the WaitForDebugEvent function.
            A process that uses <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS"/> becomes the root of a debugging chain. This continues until another process in the chain is created with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_PROCESS"/>.
            If this flag is combined with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.DEBUG_ONLY_THIS_PROCESS"/>, the caller debugs only the new process, not any child processes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.DETACHED_PROCESS">
            <summary>
            For console processes, the new process does not inherit its parent's console (the default). The new process can call the AllocConsole function at a later time to create a console. For more information, see Creation of a Console.
            This value cannot be used with <see cref="F:PInvoke.Kernel32.CreateProcessFlags.CREATE_NEW_CONSOLE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.EXTENDED_STARTUPINFO_PRESENT">
            <summary>
            The process is created with extended startup information; the lpStartupInfo parameter specifies a STARTUPINFOEX structure.
            Windows Server 2003 and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreateProcessFlags.INHERIT_PARENT_AFFINITY">
            <summary>
            The process inherits its parent's affinity. If the parent process has threads in more than one processor group, the new process inherits the group-relative affinity of an arbitrary group in use by the parent.
            Windows Server 2008, Windows Vista, Windows Server 2003, and Windows XP:  This value is not supported.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.CreationDisposition">
            <summary>
            Describes an action to take on a file or device that exists or does not exist.
            </summary>
            <remarks>
            These are flags to pass to the CreateFile method's dwCreationDisposition parameter.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.CREATE_NEW">
            <summary>
            Creates a new file. The function fails if a specified file exists.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.CREATE_ALWAYS">
            <summary>
            Creates a new file, always.
            If a file exists, the function overwrites the file, clears the existing attributes, combines the specified file attributes,
            and flags with FILE_ATTRIBUTE_ARCHIVE, but does not set the security descriptor that the SECURITY_ATTRIBUTES structure specifies.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.OPEN_EXISTING">
            <summary>
            Opens a file. The function fails if the file does not exist.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.OPEN_ALWAYS">
            <summary>
            Opens a file, always.
            If a file does not exist, the function creates a file as if dwCreationDisposition is CREATE_NEW.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.CreationDisposition.TRUNCATE_EXISTING">
            <summary>
            Opens a file and truncates it so that its size is 0 (zero) bytes. The function fails if the file does not exist.
            The calling process must open the file with the GENERIC_WRITE access right.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ErrorModes.SEM_DEFAULT">
            <summary>
            Use the system default, which is to display all error dialog boxes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ErrorModes.SEM_FAILCRITICALERRORS">
            <summary>
            <para>
                The system does not display the critical-error-handler message box.
                Instead, the system sends the error to the calling process.
            </para>
            <para>
                 Best practice is that all applications call the process-wide <see cref="M:PInvoke.Kernel32.SetErrorMode(PInvoke.Kernel32.ErrorModes)"/> function
                 with a parameter of <see cref="F:PInvoke.Kernel32.ErrorModes.SEM_FAILCRITICALERRORS"/> at startup.
                 This is to prevent error mode dialogs from hanging the application.
            </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ErrorModes.SEM_NOALIGNMENTFAULTEXCEPT">
            <summary>
            <para>
                The system automatically fixes memory alignment faults and makes them invisible to the application.
                It does this for the calling process and any descendant processes.
                This feature is only supported by certain processor architectures.
            </para>
            <para>
                After this value is set for a process, subsequent attempts to clear the value are ignored.
            </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ErrorModes.SEM_NOGPFAULTERRORBOX">
            <summary>
            The system does not display the Windows Error Reporting dialog.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ErrorModes.SEM_NOOPENFILEERRORBOX">
            <summary>
            The OpenFile function does not display a message box when it fails to find a file.
            Instead, the error is returned to the caller. This error mode overrides the OF_PROMPT flag.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FileAccess">
            <summary>
            Enumerates the <see cref="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights"/> that may apply to files.
            </summary>
            <remarks>
            These flags may be passed to CreateFile.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_DATA">
            <summary>
                For a file object, the right to read the corresponding file data. For a directory object, the right to read
                the corresponding directory data.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_LIST_DIRECTORY">
            <summary>For a directory, the right to list the contents of the directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA">
            <summary>
                For a file object, the right to write data to the file. For a directory object, the right to create a file in
                the directory (<see cref="F:PInvoke.Kernel32.FileAccess.FILE_ADD_FILE" />).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_ADD_FILE">
            <summary>For a directory, the right to create a file in the directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_APPEND_DATA">
            <summary>
                For a file object, the right to append data to the file. (For local files, write operations will not overwrite
                existing data if this flag is specified without <see cref="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_DATA" />.) For a directory object, the right
                to create a subdirectory (<see cref="F:PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY" />).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_ADD_SUBDIRECTORY">
            <summary>For a directory, the right to create a subdirectory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_CREATE_PIPE_INSTANCE">
            <summary>For a named pipe, the right to create a pipe.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_EA">
            <summary>The right to read extended file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_EA">
            <summary>The right to write extended file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_EXECUTE">
            <summary>
                For a native code file, the right to execute the file. This access right given to scripts may cause the script
                to be executable, depending on the script interpreter.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_TRAVERSE">
            <summary>
                For a directory, the right to traverse the directory. By default, users are assigned the
                BYPASS_TRAVERSE_CHECKING privilege, which ignores the FILE_TRAVERSE access right.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_DELETE_CHILD">
            <summary>For a directory, the right to delete a directory and all the files it contains, including read-only files.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_READ_ATTRIBUTES">
            <summary>The right to read file attributes.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAccess.FILE_WRITE_ATTRIBUTES">
            <summary>The right to write file attributes.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.FileAttribute">
            <summary>Defines the Win32 FileAttributes enum.</summary>
            <remarks>
                This is similar to the System.IO.FileAttributes enum, but that enum is not available in the portable profile,
                although it is allowed to call certain file methods via P/Invoke in Windows Store apps, per MSDN docs. A value
                typed as this enum may be safely cast to the System.IO.FileAttributes enum, as all the value names have equal
                ordinal values.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ARCHIVE">
            <summary>
                A file or directory that is an archive file or directory. Applications typically use this attribute to mark
                files for backup or removal.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_COMPRESSED">
            <summary>
                A file or directory that is compressed. For a file, all of the data in the file is compressed. For a
                directory, compression is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DEVICE">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_DIRECTORY">
            <summary>The handle that identifies a directory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_ENCRYPTED">
            <summary>
                A file or directory that is encrypted. For a file, all data streams in the file are encrypted. For a
                directory, encryption is the default for newly created files and subdirectories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_HIDDEN">
            <summary>The file or directory is hidden. It is not included in an ordinary directory listing.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_INTEGRITY_STREAM">
            <summary>
                The directory or user data stream is configured with integrity (only supported on ReFS volumes). It is not
                included in an ordinary directory listing. The integrity setting persists with the file if it's renamed. If a file
                is copied the destination file will have integrity set if either the source file or destination directory have
                integrity set.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NORMAL">
            <summary>A file that does not have other attributes set. This attribute is valid only when used alone.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED">
            <summary>The file or directory is not to be indexed by the content indexing service.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_NO_SCRUB_DATA">
            <summary>
                The user data stream not to be read by the background data integrity scanner (AKA scrubber). When set on a
                directory it only provides inheritance. This flag is only supported on Storage Spaces and ReFS volumes. It is not
                included in an ordinary directory listing.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_OFFLINE">
            <summary>
                The data of a file is not available immediately. This attribute indicates that the file data is physically
                moved to offline storage. This attribute is used by Remote Storage, which is the hierarchical storage management
                software. Applications should not arbitrarily change this attribute.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_READONLY">
            <summary>
                A file that is read-only. Applications can read the file, but cannot write to it or delete it. This attribute
                is not honored on directories.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_REPARSE_POINT">
            <summary>A file or directory that has an associated reparse point, or a file that is a symbolic link.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SPARSE_FILE">
            <summary>A file that is a sparse file.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_SYSTEM">
            <summary>A file or directory that the operating system uses a part of, or uses exclusively.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_TEMPORARY">
            <summary>
                A file that is being used for temporary storage. File systems avoid writing data back to mass storage if
                sufficient cache memory is available, because typically, an application deletes a temporary file after the handle
                is closed. In that scenario, the system can entirely avoid writing the data. Otherwise, the data is written after
                the handle is closed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileAttribute.FILE_ATTRIBUTE_VIRTUAL">
            <summary>This value is reserved for system use.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.None">
            <summary>
            Prevents other processes from opening a file or device if they request delete, read, or write access.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_READ">
            <summary>
            Enables subsequent open operations on an object to request read access.
            Otherwise, other processes cannot open the object if they request read access.
            If this flag is not specified, but the object has been opened for read access, the function fails.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_WRITE">
            <summary>
            Enables subsequent open operations on an object to request write access.
            Otherwise, other processes cannot open the object if they request write access.
            If this flag is not specified, but the object has been opened for write access, the function fails.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileShare.FILE_SHARE_DELETE">
            <summary>
            Enables subsequent open operations on an object to request delete access.
            Otherwise, other processes cannot open the object if they request delete access.
            If this flag is not specified, but the object has been opened for delete access, the function fails.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FileSystemFlags">
            <summary>
            Flags associated with a file system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_CASE_SENSITIVE_SEARCH">
            <summary>
            The file system supports case-sensitive file names.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_CASE_PRESERVED_NAMES">
            <summary>
            The file system preserves the case of file names when it places a name on disk.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_UNICODE_ON_DISK">
            <summary>
            The file system supports Unicode in file names as they appear on disk.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_PERSISTENT_ACLS">
            <summary>
            The file system preserves and enforces access control lists (ACL).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_FILE_COMPRESSION">
            <summary>
            The file system supports file-based compression.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_VOLUME_QUOTAS">
            <summary>
            The file system supports disk quotas.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_SPARSE_FILES">
            <summary>
            The file system supports sparse files.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_REPARSE_POINTS">
            <summary>
            The file system supports re-parse points.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_VOLUME_IS_COMPRESSED">
            <summary>
            The specified volume is a compressed volume, for example, a DoubleSpace volume.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_OBJECT_IDS">
            <summary>
            The file system supports object identifiers.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_ENCRYPTION">
            <summary>
            The file system supports the Encrypted File System (EFS).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_NAMED_STREAMS">
            <summary>
            The file system supports named streams.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_READ_ONLY_VOLUME">
            <summary>
            The specified volume is read-only.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SEQUENTIAL_WRITE_ONCE">
            <summary>
            The volume supports a single sequential write.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_TRANSACTIONS">
            <summary>
            The volume supports transactions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_HARD_LINKS">
            <summary>
            The specified volume supports hard links.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_EXTENDED_ATTRIBUTES">
            <summary>
            The specified volume supports extended attributes.
            An extended attribute is a piece of application-specific metadata that an application can associate
            with a file and is not part of the file's data.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_OPEN_BY_FILE_ID">
            <summary>
            The file system supports open by FileID.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_SUPPORTS_USN_JOURNAL">
            <summary>
            The specified volume supports update sequence number (USN) journals.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FileSystemFlags.FILE_DAX_VOLUME">
            <summary>
            The specified volume is a direct access (DAX) volume.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FILETIME">
            <summary>
            A 64-bit representation of a file timestamp.
            </summary>
            <remarks>
            This type is equivalent to <see cref="T:System.Runtime.InteropServices.ComTypes.FILETIME"/>.
            We couldn't use that type directly even though it's in the portable profile because
            Xamarin.Android and Xamarin.iOS omit the type and it causes link failures.
            See https://github.com/dotnet/pinvoke/issues/232.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwLowDateTime">
            <summary>
            Specifies the low 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FILETIME.dwHighDateTime">
            <summary>
            Specifies the high 32 bits of the FILETIME.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.FILETIME.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.FILETIME"/> struct.
            </summary>
            <param name="dateTime">The DateTime to initialize to.</param>
        </member>
        <member name="M:PInvoke.Kernel32.FILETIME.op_Implicit(PInvoke.Kernel32.FILETIME)~System.Int64">
            <summary>
            Convert to <see cref="T:System.Int64"/> to ease interop with <see cref="T:System.TimeSpan"/> or <see cref="T:System.DateTime"/>.
            </summary>
            <param name="fileTime"> The fileTime structure to be converted to long.</param>
        </member>
        <member name="M:PInvoke.Kernel32.FILETIME.op_Explicit(PInvoke.Kernel32.FILETIME)~System.DateTime">
            <summary>
            Creates a <see cref="T:System.DateTime"/> value that represents the same time as this value.
            </summary>
            <param name="fileTime">The value to be converted.</param>
        </member>
        <member name="T:PInvoke.Kernel32.FindFirstFileExFlags">
            <summary>
            Optional flags to pass to the <see cref="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_CASE_SENSITIVE">
            <summary>
            Searches are case-sensitive.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FindFirstFileExFlags.FIND_FIRST_EX_LARGE_FETCH">
            <summary>
            Uses a larger buffer for directory queries, which can increase performance of the find operation.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.FormatMessageFlags">
            <summary>
            Flags passed to the <see cref="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)"/> method.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER">
            <summary>
                The function allocates a buffer large enough to hold the formatted message, and places a pointer to the allocated
                buffer at the address specified by lpBuffer. The nSize parameter specifies the minimum number of TCHARs to allocate
                for an output message buffer. The caller should use the LocalFree function to free the buffer when it is no longer
                needed.
                <para>
                    If the length of the formatted message exceeds 128K bytes, then FormatMessage will fail and a subsequent call
                    to <see cref="M:PInvoke.Kernel32.GetLastError" /> will return <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    In previous versions of Windows, this value was not available for use when compiling Windows Store apps. As
                    of Windows 10 this value can be used.
                </para>
                <para>
                    Windows Server 2003 and Windows XP: If the length of the formatted message exceeds 128K bytes, then
                    FormatMessage will not automatically fail with an error of <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />.
                </para>
                <para>
                    Windows 10: LocalFree is not in the modern SDK, so it cannot be used to free the result buffer. Instead, use
                    HeapFree (GetProcessHeap(), allocatedMessage). In this case, this is the same as calling LocalFree on memory.
                </para>
                <para>
                    Important: LocalAlloc() has different options: LMEM_FIXED, and LMEM_MOVABLE. FormatMessage() uses LMEM_FIXED,
                    so HeapFree can be used. If LMEM_MOVABLE is used, HeapFree cannot be used.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY">
            <summary>
                The Arguments parameter is not a va_list structure, but is a pointer to an array of values that represent the
                arguments. This flag cannot be used with 64-bit integer values. If you are using a 64-bit integer, you must use the
                va_list structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE">
            <summary>
                The lpSource parameter is a module handle containing the message-table resource(s) to search. If this lpSource
                handle is NULL, the current process's application image file will be searched. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If the module has no message table resource, the function fails with
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_RESOURCE_TYPE_NOT_FOUND" />.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING">
            <summary>
                The lpSource parameter is a pointer to a null-terminated string that contains a message definition. The
                message definition may contain insert sequences, just as the message text in a message table resource may. This
                flag cannot be used with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" /> or <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM" />.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_SYSTEM">
            <summary>
                The function should search the system message-table resource(s) for the requested message. If this flag is
                specified with <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE" />, the function searches the system message table if the
                message is not found in the module specified by lpSource. This flag cannot be used with
                <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
                <para>
                    If this flag is specified, an application can pass the result of the <see cref="M:PInvoke.Kernel32.GetLastError" /> function to
                    retrieve the message text for a system-defined error.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_IGNORE_INSERTS">
            <summary>
                Insert sequences in the message definition are to be ignored and passed through to the output buffer
                unchanged. This flag is useful for fetching a message for later formatting. If this flag is set, the Arguments
                parameter is ignored.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_MAX_WIDTH_MASK">
            <summary>
                The function ignores regular line breaks in the message definition text. The function stores hard-coded line breaks
                in the message definition text into the output buffer. The function generates no new line breaks.
                <para>
                    Without this flag set: There are no output line width restrictions. The function stores line breaks that are
                    in the message definition text into the output buffer. It specifies the maximum number of characters in an
                    output line. The function ignores regular line breaks in the message definition text. The function never splits
                    a string delimited by white space across a line break. The function stores hard-coded line breaks in the
                    message definition text into the output buffer. Hard-coded line breaks are coded with the %n escape sequence.
                </para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.HandleFlags.HANDLE_FLAG_NONE">
            <summary>
            Indicates that none of the flags are set.
            </summary>
            <remarks>
            This value is not defined in Win32 API headers.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.HandleFlags.HANDLE_FLAG_INHERIT">
            <summary>
            If this flag is set, a child process created with the bInheritHandles parameter of CreateProcess set to TRUE will inherit the object handle.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.HandleFlags.HANDLE_FLAG_PROTECT_FROM_CLOSE">
            <summary>
            If this flag is set, calling the <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/> function will not close the object handle.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.MemoryPriority">
            <summary>
            The memory priority for the thread or process can be one of the following values.
            </summary>
            <remarks>
            The memory priority of a thread or process serves as a hint to the memory manager when it trims pages from the working set.
            Other factors being equal, pages with lower memory priority are trimmed before pages with higher memory priority.
            See also <a href="https://docs.microsoft.com/en-us/windows/desktop/Memory/working-set">Working Set</a>.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.MemoryPriority.MEMORY_PRIORITY_LOWEST">
            <summary>
            Lowest memory priority
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MemoryPriority.MEMORY_PRIORITY_VERY_LOW">
            <summary>
            Very low memory priority
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MemoryPriority.MEMORY_PRIORITY_LOW">
            <summary>
            Low memory priority
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MemoryPriority.MEMORY_PRIORITY_MEDIUM">
            <summary>
            Medium memory priority
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MemoryPriority.MEMORY_PRIORITY_BELOW_NORMAL">
            <summary>
            Below normal memory priority
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MemoryPriority.MEMORY_PRIORITY_NORMAL">
            <summary>
            Normal memory priority. This is the default priority for all threads and processes on the system
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.MEMORY_PRIORITY_INFORMATION">
            <summary>
            Specifies the memory priority for a thread or process.
            This structure is used by the GetProcessInformation, SetProcessInformation, GetThreadInformation, and SetThreadInformation
            functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MEMORY_PRIORITY_INFORMATION.MemoryPriority">
            <summary>
            The memory priority for the thread or process.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.OSPlatformId">
            <summary>
            The <see cref="T:PInvoke.Kernel32.OSPlatformId"/> structure contains operating system version information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSPlatformId.VER_PLATFORM_WIN32s">
            <summary>
            The operating system is Microsoft Windows 3.1.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSPlatformId.VER_PLATFORM_WIN32_WINDOWS">
            <summary>
            The operating system is Windows 95, Windows 98, or operating systems descended from them.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSPlatformId.VER_PLATFORM_WIN32_NT">
            <summary>
            The operating system is Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, Windows XP, or Windows 2000.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.OSVERSIONINFO">
            <summary>
            The <see cref="T:PInvoke.Kernel32.OSVERSIONINFO"/> structure contains operating system version information.
            </summary>
            <see href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfow"/>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFO.dwOSVersionInfoSize">
            <summary>
            The size of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFO"/> structure in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFO.dwMajorVersion">
            <summary>
            The major OS version.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFO.dwMinorVersion">
            <summary>
            The minor OS version.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFO.dwBuildNumber">
            <summary>
            The build number of the OS.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFO.dwPlatformId">
            <summary>
            The OS platform.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFO.szCSDVersion">
            <summary>
            A null-terminated string, such as "Service Pack 3", that indicates the latest Service Pack installed on the system.
            If no Service Pack has been installed, the string is empty.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.OSVERSIONINFO.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFO" /> struct
            with <see cref="F:PInvoke.Kernel32.OSVERSIONINFO.dwOSVersionInfoSize" /> set to the correct value.
            </summary>
            <returns>
            A newly initialized instance of <see cref="T:PInvoke.Kernel32.OSVERSIONINFO"/>.
            </returns>
        </member>
        <member name="T:PInvoke.Kernel32.OSVERSIONINFOEX">
            <summary>
            The RTL_OSVERSIONINFOEXW structure contains operating system version information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize">
            <summary>
            The size, in bytes, of an RTL_OSVERSIONINFOEXW structure.
            This member must be set before the structure is used with RtlGetVersion.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwMajorVersion">
            <summary>
            The major version number of the operating system. For example, for Windows 2000, the major version number is five.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwMinorVersion">
            <summary>
            The minor version number of the operating system. For example, for Windows 2000, the minor version number is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwBuildNumber">
            <summary>
            The build number of the operating system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwPlatformId">
            <summary>
            The operating system platform. For Win32 on NT-based operating systems, RtlGetVersion returns the value
            VER_PLATFORM_WIN32_NT.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.szCSDVersion">
            <summary>
            The service-pack version string. This member contains a null-terminated string, such as "Service Pack 3", which
            indicates the latest service pack installed on the system. If no service pack is installed, RtlGetVersion might not
            initialize this string. Initialize szCSDVersion to zero (empty string) before the call to RtlGetVersion.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wServicePackMajor">
            <summary>
            The major version number of the latest service pack installed on the system. For example, for Service Pack 3,
            the major version number is three. If no service pack has been installed, the value is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wServicePackMinor">
            <summary>
            The minor version number of the latest service pack installed on the system. For example, for Service Pack 3,
            the minor version number is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wSuiteMask">
            <summary>
            The product suites available on the system. This member is set to zero or to the bitwise OR of one or more of
            the <see cref="T:PInvoke.Kernel32.PRODUCT_SUITE"/> values.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wProductType">
            <summary>
            The product type. This member contains additional information about the system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OSVERSIONINFOEX.wReserved">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.OSVERSIONINFOEX.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX" /> struct
            with <see cref="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize" /> set to the correct value.
            </summary>
            <returns>
            A newly initialized instance of <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/>.
            </returns>
        </member>
        <member name="T:PInvoke.Kernel32.OS_TYPE">
            <summary>
            The product type enumeration.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OS_TYPE.VER_NT_WORKSTATION">
            <summary>
            The operating system is Windows 8, Windows 7, Windows Vista, Windows XP Professional, Windows XP Home Edition, or Windows 2000 Professional.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OS_TYPE.VER_NT_DOMAIN_CONTROLLER">
            <summary>
            The system is a domain controller and the operating system is Windows Server 2012 , Windows Server 2008 R2,
            Windows Server 2008, Windows Server 2003, or Windows 2000 Server.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OS_TYPE.VER_NT_SERVER">
            <summary>
            The operating system is Windows Server 2012, Windows Server 2008 R2, Windows Server 2008, Windows Server 2003, or Windows 2000 Server.
            </summary>
            <remarks>
            Note that a server that is also a domain controller is reported as <see cref="F:PInvoke.Kernel32.OS_TYPE.VER_NT_DOMAIN_CONTROLLER"/>, not <see cref="F:PInvoke.Kernel32.OS_TYPE.VER_NT_SERVER"/>.
            </remarks>
        </member>
        <member name="T:PInvoke.Kernel32.OVERLAPPED">
            <summary>Contains information used in asynchronous (or overlapped) input and output (I/O).</summary>
            <remarks>
            Any unused members of this structure should always be initialized to zero before the structure is used in a function
            call. Otherwise, the function may fail and return <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_PARAMETER"/>.
            <para>
            The Offset and OffsetHigh members together represent a 64-bit file position.It is a byte offset from the start of
            the file or file-like device, and it is specified by the user; the system will not modify these values.The calling
            process must set this member before passing the OVERLAPPED structure to functions that use an offset, such as the
            ReadFile or WriteFile (and related) functions.
            </para>
            <para>
            You can use the HasOverlappedIoCompleted macro to check whether an asynchronous I/O operation has completed if
            GetOverlappedResult is too cumbersome for your application.
            </para>
            <para>You can use the CancelIo function to cancel an asynchronous I/O operation.</para>
            <para>
            A common mistake is to reuse an OVERLAPPED structure before the previous asynchronous operation has been
            completed. You should use a separate structure for each request. You should also create an event object for each thread
            that processes data. If you store the event handles in an array, you could easily wait for all events to be signaled
            using the WaitForMultipleObjects function.
            </para>
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Internal">
            <summary>
            The status code for the I/O request. When the request is issued, the system sets this member to STATUS_PENDING to indicate that the operation has not yet started. When the request is completed, the system sets this member to the status code for the completed request.
            <para>The Internal member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.InternalHigh">
            <summary>
            The number of bytes transferred for the I/O request. The system sets this member if the request is completed without errors.
            <para>The InternalHigh member was originally reserved for system use and its behavior may change.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.Offset">
            <summary>
            The low-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.OffsetHigh">
            <summary>
            The high-order portion of the file position at which to start the I/O request, as specified by the user.
            <para>This member is nonzero only when performing I/O requests on a seeking device that supports the concept of an offset(also referred to as a file pointer mechanism), such as a file.Otherwise, this member must be zero.</para>
            <para>For additional information, see Remarks.</para>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.OVERLAPPED.hEvent">
            <summary>
            A handle to the event that will be set to a signaled state by the system when the operation has completed. The user must initialize this member either to zero or a valid event handle using the CreateEvent function before passing this structure to any overlapped functions. This event can then be used to synchronize simultaneous I/O requests for a device. For additional information, see Remarks.
            <para>Functions such as ReadFile and WriteFile set this handle to the nonsignaled state before they begin an I/O operation.When the operation has completed, the handle is set to the signaled state.</para>
            <para>Functions such as GetOverlappedResult and the synchronization wait functions reset auto-reset events to the nonsignaled state. Therefore, you should use a manual reset event; if you use an auto-reset event, your application can stop responding if you wait for the operation to complete and then call GetOverlappedResult with the bWait parameter set to TRUE.</para>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessAccess">
            <summary>
            Enumerates the <see cref="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights"/> that may apply to processes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_CREATE_PROCESS">
            <summary>Required to create a process.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_CREATE_THREAD">
            <summary>Required to create a thread.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_DUP_HANDLE">
            <summary>Required to duplicate a handle using DuplicateHandle.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION">
            <summary>
            Required to retrieve certain information about a process, such as its token, exit code, and priority class
            (see OpenProcessToken).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION">
            <summary>
            Required to retrieve certain information about a process (see GetExitCodeProcess, GetPriorityClass,
            IsProcessInJob, QueryFullProcessImageName). A handle that has the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION" /> access right
            is automatically granted <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION" />.
            </summary>
            <remarks>Windows Server 2003 and Windows XP:  This access right is not supported.</remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SET_INFORMATION">
            <summary>Required to set certain information about a process, such as its priority class (see SetPriorityClass).</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SET_QUOTA">
            <summary>Required to set memory limits using SetProcessWorkingSetSize.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SUSPEND_RESUME">
            <summary>Required to suspend or resume a process.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_TERMINATE">
            <summary>Required to terminate a process using TerminateProcess.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_OPERATION">
            <summary>
            Required to perform an operation on the address space of a process (see VirtualProtectEx and
            WriteProcessMemory).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_READ">
            <summary>Required to read memory in a process using ReadProcessMemory.</summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessAccess.PROCESS_VM_WRITE">
            <summary>Required to write to memory in a process using WriteProcessMemory.</summary>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessLeapSecondInfoFlags">
            <summary>
            Flags used in <see cref="F:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO.Flags"/> field.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessLeapSecondInfoFlags.None">
            <summary>
            No flags
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessLeapSecondInfoFlags.PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND">
            <summary>
            This value changes the way positive leap seconds are handled by system. Specifically, it changes how the seconds field during a positive
            leap second is handled by the system. If this value is used, then the positive leap second will be shown
            (For example: 23:59:59 -> 23:59:60 -> 00:00:00. If this value is not used, then "sixty seconds" is disabled, and the 59th second preceding a positive
            leap second will be shown for 2 seconds with the milliseconds value ticking twice as slow. So 23:59:59 -> 23:59:59.500 -> 00:00:00, which takes 2
            seconds in wall clock time. Disabling "sixty second" can help with legacy apps that do not support seeing the seconds value as 60 during the positive
            leap second. Such apps may crash or misbehave. Therefore, in these cases, we display the 59th second for twice as long during the positive leap second.
            Note that this setting is per-process, and does not persist if the process is restarted. Developers should test their app for compatibility with seeing
            the system return "60", and add a call to their app startup routines to either enable or disable "sixty seconds". "Sixty seconds" is disabled by default
            for each process. Obviously, this setting has no effect if leap seconds are disabled system-wide, because then the system will never even encounter a
            leap second.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessorArchitecture">
            <summary>
            The processor architecture of the installed operating system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_AMD64">
            <summary>
            x64 (AMD or Intel)
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_ARM">
            <summary>
            ARM
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_ARM64">
            <summary>
            ARM64
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_IA64">
            <summary>
            Intel Itanium-based
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_INTEL">
            <summary>
            x86
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessorArchitecture.PROCESSOR_ARCHITECTURE_UNKNOWN">
            <summary>
            Unknown architecture.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessorPowerThrottlingFlags">
            <summary>
            Flags used with <see cref="T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE"/> fields.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessorPowerThrottlingFlags.None">
            <summary>
            Turns off power throttling policy when set on <see cref="F:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE.StateMask"/>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessorPowerThrottlingFlags.PROCESS_POWER_THROTTLING_EXECUTION_SPEED">
             <summary>
             Used when <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessPowerThrottling"/> is being set (or queried) using
             <see cref="M:PInvoke.Kernel32.GetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.Void*,System.UInt32)"/> or
             SetProcessInformation.
            
             When set on <see cref="F:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE.ControlMask"/>, it indicates that ExecutionSpeed
             throttling is being selected.
            
             When set on <see cref="F:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE.StateMask"/>, it indicates whether throttling is
             on (or off; use <see cref="F:PInvoke.Kernel32.ProcessorPowerThrottlingFlags.None"/> to turn off ExecutionSpeed throttling).
             </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESSOR_NUMBER">
            <summary>
            Represents a logical processor in a processor group.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSOR_NUMBER.Group">
            <summary>
            The processor group to which the logical processor is assigned.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSOR_NUMBER.Number">
            <summary>
            The number of the logical processor relative to the group.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESSOR_NUMBER.Reserved">
            <summary>
            This parameter is reserved.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessPriorityClass">
             <summary>
             Process' priority class.
             </summary>
             <remarks>
             Every thread has a base priority level determined by the thread's priority value and the priority class of its process. The operating system
             uses the base priority level of all executable threads to determine which thread gets the next slice of CPU time. Threads are scheduled in a
             round-robin fashion at each priority level, and only when there are no executable threads at a higher level will scheduling of threads at a
             lower level take place.
            
             For a table that shows the base priority levels for each combination of priority class and thread priority value, see
             <a href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>
            
             Priority class is maintained by the executive, so all processes have a priority class that can be queried.
             </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessPriorityClass.ABOVE_NORMAL_PRIORITY_CLASS">
            <summary>
            Process that has priority above <see cref="F:PInvoke.Kernel32.ProcessPriorityClass.NORMAL_PRIORITY_CLASS"/> but below <see cref="F:PInvoke.Kernel32.ProcessPriorityClass.HIGH_PRIORITY_CLASS"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessPriorityClass.BELOW_NORMAL_PRIORITY_CLASS">
            <summary>
            Process that has priority above <see cref="F:PInvoke.Kernel32.ProcessPriorityClass.IDLE_PRIORITY_CLASS"/> but below <see cref="F:PInvoke.Kernel32.ProcessPriorityClass.NORMAL_PRIORITY_CLASS"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessPriorityClass.HIGH_PRIORITY_CLASS">
            <summary>
            Process that performs time-critical tasks that must be executed immediately for it to run correctly. The threads of a high-priority
            class process preempt the threads of normal or idle priority class processes. An example is the Task List, which must respond quickly
            when called by the user, regardless of the load on the operating system. Use extreme care when using the high-priority class, because a
            high-priority class CPU-bound application can use nearly all available cycles.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessPriorityClass.IDLE_PRIORITY_CLASS">
            <summary>
            Process whose threads run only when the system is idle and are preempted by the threads of any process running in a higher priority class.
            An example is a screen saver. The idle priority class is inherited by child processes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessPriorityClass.NORMAL_PRIORITY_CLASS">
            <summary>
            Process with no special scheduling needs.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessPriorityClass.REALTIME_PRIORITY_CLASS">
            <summary>
            Process that has the highest possible priority. The threads of a real-time priority class process preempt the threads of all other processes,
            including operating system processes performing important tasks. For example, a real-time process that executes for more than a very brief
            interval can cause disk caches not to flush or cause the mouse to be unresponsive.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ProcessProtectionLevel">
            <summary>
            Process ProtectionLevel values.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_WINTCB_LIGHT">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_WINDOWS">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_WINDOWS_LIGHT">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_ANTIMALWARE_LIGHT">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_LSA_LIGHT">
            <summary>
            For internal use only
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_WINTCB">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_CODEGEN_LIGHT">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_AUTHENTICODE">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_PPL_APP">
            <summary>
            The process is a third party app that is using process protection.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_NONE">
            <summary>
            The process is not protected.
            </summary>
            <remarks>
            This is only used as a value for ProtectionLevel when querying
            ProcessProtectionLevelInfo in GetProcessInformation.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.ProcessProtectionLevel.PROTECTION_LEVEL_SAME">
            <summary>
            Supplied for testing only
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS">
            <summary>
            Indicates a specific class of process information. Values from this enumeration are passed into
            the <see cref="M:PInvoke.Kernel32.GetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.Void*,System.UInt32)"/>
            and <see cref="M:PInvoke.Kernel32.SetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.Void*,System.UInt32)"/>
            functions to specify the type of process information passed in the void pointer argument of the function call.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessMemoryPriority">
            <summary>
            The process information is represented by a <see cref="T:PInvoke.Kernel32.MEMORY_PRIORITY_INFORMATION"/> structure.
            Allows applications to lower the default memory priority of threads that perform background operations or access files and data
            that are not expected to be accessed again soon.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessMemoryExhaustionInfo">
            <summary>
            The process information is represented by a <see cref="T:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO"/> structure.
            Allows applications to configure a process to terminate if an allocation fails to commit memory.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessAppMemoryInfo">
            <summary>
            The process information is represented by a <see cref="T:PInvoke.Kernel32.APP_MEMORY_INFORMATION"/> structure.
            Allows applications to query the commit usage and the additional commit available to this process. Does not
            allow the caller to actually get a commit limit.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessInPrivateInfo">
            <summary>
            If a process is set to ProcessInPrivate mode, and a trace session has set the EVENT_ENABLE_PROPERTY_EXCLUDE_INPRIVATE flag, then the
            trace session will drop all events from that process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessPowerThrottling">
            <summary>
            The process information is represented by a <see cref="T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE"/> structure. Allows applications to configure how
            the system should throttle the target process’s activity when managing power.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessReservedValue1">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessTelemetryCoverageInfo">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessProtectionLevelInfo">
            <summary>
            The process information is represented by a <see cref="T:PInvoke.Kernel32.PROCESS_PROTECTION_LEVEL_INFORMATION"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessLeapSecondInfo">
            <summary>
            The process information is represented by a <see cref="T:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessInformationClassMax">
            <summary>
            The maximum value for this enumeration. This value may change in a future version.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO">
            <summary>
            Specifies how the system handles positive leap seconds.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO.Flags">
            <summary>
            Flag specifying how the system handles leap seconds.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO.Reserved">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO">
            <summary>
            Allows applications to configure a process to terminate if an allocation fails to commit memory.
            This structure is used by the <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS"/> class.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.PME_CURRENT_VERSION">
            <summary>
            The only valid value for <see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.Version"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.PME_FAILFAST_ON_COMMIT_FAIL_DISABLE">
            <summary>
            Value for <see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.Value"/> field to disable
            the <see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure"/> feature.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.PME_FAILFAST_ON_COMMIT_FAIL_ENABLE">
            <summary>
            Value for <see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.Value"/> field to enable
            the <see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure"/> feature.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.Version">
            <summary>
            This should be set to <see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.PME_CURRENT_VERSION"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.Reserved">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.Type">
            <summary>
            Type should be set to <see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure"/> (this is the only
            type available).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.Value">
            <summary>
            Used to turn the feature on or off.
             <list type="table">
             <listheader><term>Function</term><term>Setting</term></listheader>
             <item><term>Enable</term><term><see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.PME_FAILFAST_ON_COMMIT_FAIL_ENABLE"/></term></item>
             <item><term>Disable</term><term><see cref="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_INFO.PME_FAILFAST_ON_COMMIT_FAIL_ENABLE"/></term></item>
             </list>
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_TYPE">
            <summary>
            Represents the different memory exhaustion types.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure">
             <summary>
             Anytime memory management fails an allocation due to an inability to commit memory, it will cause the process to trigger a Windows
             Error Reporting report and then terminate immediately with <see cref="F:PInvoke.NTSTATUS.Code.STATUS_COMMITMENT_LIMIT"/>.
            
             The failure cannot be caught and handled by the app.
             </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeMax">
            <summary>
            The maximum value for this enumeration. This value may change in a future version.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE">
            <summary>
            Specifies the throttling policies and how to apply them to a target process when that process is
            subject to power management.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE.PROCESS_POWER_THROTTLING_CURRENT_VERSION">
            <summary>
            The current version of the <see cref="T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE.Version">
             <summary>
             The version of this structre.
            
             <list type="table">
             <listheader><term>Value</term><term>Meaning</term></listheader>
             <item><term><see cref="F:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE.PROCESS_POWER_THROTTLING_CURRENT_VERSION"/></term><term>The current version</term></item>
             </list>
             </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE.ControlMask">
             <summary>
             This field enables the caller to take control of the power throttling mechanism.
            
             <list type="table">
                 <listheader>
                     <term>Value</term>
                     <term>Meaning</term>
                 </listheader>
                 <item>
                     <term><see cref="F:PInvoke.Kernel32.ProcessorPowerThrottlingFlags.PROCESS_POWER_THROTTLING_EXECUTION_SPEED"/></term>
                     <term>Manages the execution speed of the process</term>
                 </item>
             </list>
             </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE.StateMask">
             <summary>
             Manages the power throttling mechanism on/off state.
            
             <list type="table">
                 <listheader>
                     <term>Value</term>
                     <term>Meaning</term>
                 </listheader>
                 <item>
                     <term><see cref="F:PInvoke.Kernel32.ProcessorPowerThrottlingFlags.PROCESS_POWER_THROTTLING_EXECUTION_SPEED"/>
                     </term><term>Manages the execution speed of the process</term>
                 </item>
             </list>
             </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PROCESS_PROTECTION_LEVEL_INFORMATION">
            <summary>
            Specifies whether Protected Process Light (PPL) is enabled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PROCESS_PROTECTION_LEVEL_INFORMATION.ProtectionLevel">
            <summary>
            Process protection level.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.PRODUCT_SUITE">
            <summary>
            The product suites available on the system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_BACKOFFICE">
            <summary>
            Microsoft BackOffice components are installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_BLADE">
            <summary>
            Windows Server 2003, Web Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_COMPUTE_SERVER">
            <summary>
            Windows Server 2003, Compute Cluster Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_DATACENTER">
            <summary>
            Windows Server 2008 Datacenter, Windows Server 2003, Datacenter Edition, or Windows 2000 Datacenter Server is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_ENTERPRISE">
            <summary>
            Windows Server 2008 Enterprise, Windows Server 2003, Enterprise Edition, or Windows 2000 Advanced Server is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_EMBEDDEDNT">
            <summary>
            Windows XP Embedded is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_PERSONAL">
            <summary>
            Windows Vista Home Premium, Windows Vista Home Basic, or Windows XP Home Edition is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SINGLEUSERTS">
            <summary>
            Remote Desktop is supported, but only one interactive session is supported.
            This value is set unless the system is running in application server mode.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS">
            <summary>
            Microsoft Small Business Server was once installed on the system, but may have been upgraded to another version of Windows.
            </summary>
            <remarks>
             You should not rely solely on the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag to determine whether Small Business Server is currently installed.
             Both this flag and the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED"/> flag are set when this product suite is installed. If you upgrade this
             installation to Windows Server, Standard Edition, the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED"/> flag is cleared, but the
             <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag remains set, which, in this case, indicates that Small Business Server was previously installed on
             this system. If this installation is further upgraded to Windows Server, Enterprise Edition, the <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag
             remains set.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS_RESTRICTED">
            <summary>
            Microsoft Small Business Server is installed with the restrictive client license in force.
            For more information about this flag bit, see the remarks for <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SMALLBUSINESS"/> flag.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_STORAGE_SERVER">
            <summary>
            Windows Storage Server 2003 R2 or Windows Storage Server 2003 is installed.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_TERMINAL">
            <summary>
            Terminal Services is installed. This value is always set. If <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_TERMINAL"/> is set but <see cref="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_SINGLEUSERTS"/> is not set,
            the operating system is running in application server mode.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.PRODUCT_SUITE.VER_SUITE_WH_SERVER">
            <summary>
            Windows Home Server is installed.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SafeFindFilesHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.FindClose(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeFindFilesHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeFindFilesHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeFindFilesHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeFindFilesHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SafeLibraryHandle">
            <summary>
            Represents a library handle that can be closed with <see cref="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeLibraryHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeLibraryHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeLibraryHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeLibraryHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeLibraryHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeLibraryHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SafeObjectHandle">
            <summary>
            Represents a Win32 handle that can be closed with <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Invalid">
            <summary>
            An invalid handle that may be used in place of <see cref="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SafeObjectHandle.Null">
            <summary>
            A handle that may be used in place of <see cref="F:System.IntPtr.Zero"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SafeObjectHandle"/> class.
            </summary>
            <param name="preexistingHandle">An object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
                <see langword="true" /> to have the native handle released when this safe handle is disposed or finalized;
                <see langword="false" /> otherwise.
            </param>
        </member>
        <member name="P:PInvoke.Kernel32.SafeObjectHandle.IsInvalid">
            <inheritdoc />
        </member>
        <member name="M:PInvoke.Kernel32.SafeObjectHandle.ReleaseHandle">
            <inheritdoc />
        </member>
        <member name="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES">
            <summary>
            The SECURITY_ATTRIBUTES structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable. This structure provides security settings for objects created by various functions, such as CreateFile, CreatePipe, CreateProcess, RegCreateKeyEx, or RegSaveKeyEx.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.nLength">
            <summary>
            The size, in bytes, of this structure.
            This value is set by the constructor to the size of the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_DESCRIPTOR"/> structure that controls access to the object. If the value of this member is NULL, the object is assigned the default security descriptor associated with the access token of the calling process. This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). By default, the default DACL in the access token of a process allows access only to the user represented by the access token.
            For information about creating a security descriptor, see Creating a Security Descriptor.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="P:PInvoke.Kernel32.SECURITY_ATTRIBUTES.InheritHandle">
            <summary>
            Gets a value indicating whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SECURITY_ATTRIBUTES.Create">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> struct.
            </summary>
            <returns>A new instance of <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/>.</returns>
        </member>
        <member name="T:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL">
            <summary>
            Contains values that specify security impersonation levels. Security impersonation levels govern the degree to which a server process can act on behalf of a client process.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous">
            <summary>
            The server process cannot obtain identification information about the client, and it cannot impersonate the client. It is defined with no value given, and thus, by ANSI C rules, defaults to a value of zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityIdentification">
            <summary>
            The server process can obtain information about the client, such as security identifiers and privileges, but it cannot impersonate the client. This is useful for servers that export their own objects, for example, database products that export tables and views. Using the retrieved client-security information, the server can make access-validation decisions without being able to use other services that are using the client's security context.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation">
            <summary>
            The server process can impersonate the client's security context on its local system. The server cannot impersonate the client on remote systems.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SECURITY_IMPERSONATION_LEVEL.SecurityDelegation">
            <summary>
            The server process can impersonate the client's security context on remote systems.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.SYSTEMTIME">
            <summary>
            Specifies a date and time, using individual members for the month, day, year, weekday, hour, minute, second, and millisecond.
            The time is either in coordinated universal time (UTC) or local time, depending on the function that is being called.
            </summary>
            <remarks>
            It is not recommended that you add and subtract values from the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure to obtain relative times.
            Instead, you should
            Convert the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure.
            <list type="bullet">
            <item>
            <desccription>Copy the resulting <see cref="T:PInvoke.Kernel32.FILETIME"/> structure to a ULARGE_INTEGER structure.</desccription>
            </item>
            <item>
            <desccription>Use normal 64-bit arithmetic on the ULARGE_INTEGER value.</desccription>
            </item>
            <item>
            <description>The system can periodically refresh the time by synchronizing with a time source.</description>
            </item>
            </list>
            Because the system time can be adjusted either forward or backward, do not compare system time readings to determine elapsed time.
            Instead, use one of the methods described in Windows Time.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wYear">
            <summary>
            The year. The valid values for this member are 1601 through 30827.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMonth">
            <summary>
            The month. This member can be one of the following values.
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>1</term>
            <term>January</term>
            </item>
            <item>
            <term>2</term>
            <term>February</term>
            </item>
            <item>
            <term>3</term>
            <term>March</term>
            </item>
            <item>
            <term>4</term>
            <term>April</term>
            </item>
            <item>
            <term>5</term>
            <term>May</term>
            </item>
            <item>
            <term>6</term>
            <term>June</term>
            </item>
            <item>
            <term>7</term>
            <term>July</term>
            </item>
            <item>
            <term>8</term>
            <term>August</term>
            </item>
            <item>
            <term>9</term>
            <term>September</term>
            </item>
            <item>
            <term>10</term>
            <term>October</term>
            </item>
            <item>
            <term>11</term>
            <term>November</term>
            </item>
            <item>
            <term>12</term>
            <term>December</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wDayOfWeek">
            <summary>
            The day of the week. This member can be one of the following values.
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>Sunday</term>
            </item>
            <item>
            <term>1</term>
            <term>Monday</term>
            </item>
            <item>
            <term>2</term>
            <term>Tuesday</term>
            </item>
            <item>
            <term>3</term>
            <term>Wednesday</term>
            </item>
            <item>
            <term>4</term>
            <term>Thursday</term>
            </item>
            <item>
            <term>5</term>
            <term>Friday</term>
            </item>
            <item>
            <term>6</term>
            <term>Saturday</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wDay">
            <summary>
            The day of the month. The valid values for this member are 1 through 31.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wHour">
            <summary>
            The hour. The valid values for this member are 0 through 23.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMinute">
            <summary>
            The minute. The valid values for this member are 0 through 59.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wSecond">
            <summary>
            The second. The valid values for this member are 0 through 59.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEMTIME.wMilliseconds">
            <summary>
            The millisecond. The valid values for this member are 0 through 999.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.SYSTEMTIME.op_Implicit(PInvoke.Kernel32.SYSTEMTIME)~System.DateTime">
            <summary>
            Converts a <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> value to a <see cref="T:System.DateTime"/> value.
            </summary>
            <param name="st">The value to be converted.</param>
        </member>
        <member name="M:PInvoke.Kernel32.SYSTEMTIME.op_Implicit(System.DateTime)~PInvoke.Kernel32.SYSTEMTIME">
            <summary>
            Converts a <see cref="T:System.DateTime"/> value to a <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> value.
            </summary>
            <param name="dt">The value to be converted.</param>
        </member>
        <member name="T:PInvoke.Kernel32.SYSTEM_INFO">
            <summary>
            Contains information about the current computer system. This includes the architecture and type of
            the processor, the number of processors in the system, the page size, and other such information.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.wProcessorArchitecture">
            <summary>
            The processor architecture of the installed operating system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.wReserved">
            <summary>
            This member is reserved for future use.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.dwPageSize">
            <summary>
            The page size and the granularity of page protection and commitment.
            This is the page size used by the <c>VirtualAlloc</c> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.lpMinimumApplicationAddress">
            <summary>
            A pointer to the lowest memory address accessible to applications and dynamic-link libraries (DLLs).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.lpMaximumApplicationAddress">
            <summary>
            A pointer to the highest memory address accessible to applications and DLLs.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.dwActiveProcessorMask">
            <summary>
            A mask representing the set of processors configured into the system.
            Bit 0 is processor 0; bit 31 is processor 31.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.dwNumberOfProcessors">
            <summary>
            The number of logical processors in the current group.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.dwProcessorType">
            <summary>
            An obsolete member that is retained for compatibility.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.dwAllocationGranularity">
            <summary>
            The granularity for the starting address at which virtual memory can be allocated.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.wProcessorLevel">
            <summary>
            The architecture-dependent processor level. It should be used only for display purposes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.SYSTEM_INFO.wProcessorRevision">
            <summary>
            The architecture-dependent processor revision.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.ThreadAccess">
            <summary>
            Enumerates the <see cref="P:PInvoke.Kernel32.ACCESS_MASK.SpecificRights"/> that may apply to threads.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.SYNCHRONIZE">
            <summary>
            Enables the use of the thread handle in any of the wait functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_ALL_ACCESS">
             <summary>
             All possible access rights for a thread object.
            
             Windows Server 2003 and Windows XP: The value of the <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_ALL_ACCESS"/> flag increased on Windows Server 2008 and Windows Vista. If
             an application compiled for Windows Server 2008 and Windows Vista is run on Windows Server 2003 or Windows XP, the <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_ALL_ACCESS"/>
             flag contains access bits that are not supported and the function specifying this flag fails with <see cref="F:PInvoke.Win32ErrorCode.ERROR_ACCESS_DENIED"/>.
             To avoid this problem, specify the minimum set of access rights required for the operation. If <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_ALL_ACCESS"/> must be used, set
             _WIN32_WINNT (C, C++ applications) to the minimum operating system targeted by your application (for example, #define _WIN32_WINNT _WIN32_WINNT_WINXP).
            
             In case of C# applications that must rely on <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_ALL_ACCESS"/>, ensure that the application targets only Windows Vista or newer platforms.
             If Windows XP/Windows Server 2003 must be targeted, use the(obsolete) <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_ALL_ACCESS_WINXP"/> value.
            
             For more information, see Using the Windows Headers.
             </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_ALL_ACCESS_WINXP">
             <summary>
             All possible access rights for a thread object.
            
             See Windows XP/Windows Server 2003 specific remarks in <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_ALL_ACCESS"/> for details.
             </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_DIRECT_IMPERSONATION">
            <summary>
            Required for a server thread that impersonates a client.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_GET_CONTEXT">
            <summary>
            Required to read the context of a thread using GetThreadContext.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_IMPERSONATE">
            <summary>
            Required to use a thread's security information directly without calling it by using a communication mechanism that provides impersonation services.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_QUERY_INFORMATION">
            <summary>
            Required to read certain information from the thread object, such as the exit code (see GetExitCodeThread).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_QUERY_LIMITED_INFORMATION">
             <summary>
             Required to read certain information from the thread objects (see GetProcessIdOfThread). A handle that has the
             <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_QUERY_INFORMATION"/> access right is automatically granted <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_QUERY_LIMITED_INFORMATION"/>.
            
             Windows Server 2003 and Windows XP: This access right is not supported.
             </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_SET_CONTEXT">
            <summary>
            Required to write the context of a thread using SetThreadContext.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_SET_INFORMATION">
            <summary>
            Required to set certain information in the thread object.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_SET_LIMITED_INFORMATION">
             <summary>
             Required to set certain information in the thread object. A handle that has the <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_SET_INFORMATION"/> access right is automatically granted
             <see cref="F:PInvoke.Kernel32.ThreadAccess.THREAD_SET_LIMITED_INFORMATION"/>.
            
             Windows Server 2003 and Windows XP: This access right is not supported.
             </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_SET_THREAD_TOKEN">
            <summary>
            Required to set the impersonation token for a thread using SetThreadToken.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_SUSPEND_RESUME">
            <summary>
            Required to suspend or resume a thread (see <see cref="M:PInvoke.Kernel32.SuspendThread(PInvoke.Kernel32.SafeObjectHandle)"/> and <see cref="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)"/>).
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.ThreadAccess.THREAD_TERMINATE">
            <summary>
            Required to terminate a thread using TerminateThread.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.VER_CONDITION">
            <summary>
            The operator to be used for the comparison. The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function uses this operator to compare a specified
            attribute value to the corresponding value for the currently running system.
            </summary>
            <remarks>
            For all values of dwTypeBitMask other than VER_SUITENAME, this parameter can be one of the following values:
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_EQUAL"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER_EQUAL"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS_EQUAL"/>
            If dwTypeBitMask is VER_SUITENAME, this parameter can be one of the following values:
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_AND"/>
                - <see cref="F:PInvoke.Kernel32.VER_CONDITION.VER_OR"/>.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_EQUAL">
            <summary>
            The current value must be equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER">
            <summary>
            The current value must be greater than the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_GREATER_EQUAL">
            <summary>
            The current value must be greater than or equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS">
            <summary>
            The current value must be less than the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_LESS_EQUAL">
            <summary>
            The current value must be less than or equal to the specified value.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_AND">
            <summary>
            All product suites specified in the wSuiteMask member must be present in the current system.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_CONDITION.VER_OR">
            <summary>
            At least one of the specified product suites must be present in the current system.
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.VER_MASK">
            <summary>
            A mask that indicates the member of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure whose comparison operator is being set.
            This value corresponds to one of the bits specified in the dwTypeMask parameter for the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_BUILDNUMBER">
            <summary>
            dwBuildNumber
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_MAJORVERSION">
            <summary>
            dwBuildNumber
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_MINORVERSION">
            <summary>
            dwMinorVersion
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_PLATFORMID">
            <summary>
            dwPlatformId
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_PRODUCT_TYPE">
            <summary>
            wProductType
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SERVICEPACKMAJOR">
            <summary>
            wServicePackMajor
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SERVICEPACKMINOR">
            <summary>
            wServicePackMinor
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.VER_MASK.VER_SUITENAME">
            <summary>
            wSuiteMask
            </summary>
        </member>
        <member name="T:PInvoke.Kernel32.WaitForSingleObjectResult">
            <summary>
            Values that may be returned from the <see cref="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)"/> function.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_ABANDONED">
            <summary>
            The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread and the mutex state is set to nonsignaled.
            If the mutex was protecting persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_OBJECT_0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_TIMEOUT">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WaitForSingleObjectResult.WAIT_FAILED">
            <summary>
            The function has failed. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwFileAttributes">
            <summary>
            The file attributes of a file.
            </summary>
            <remarks>
            Although the enum we bind to here exists in the .NET Framework
            as System.IO.FileAttributes, it is not reliably present.
            Portable profiles don't include it, for example. So we have to define our own.
            </remarks>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftCreationTime">
            <summary>
            A FILETIME structure that specifies when a file or directory was created.
            If the underlying file system does not support creation time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastAccessTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last read from, written to, or for executable files, run.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last access time, this member is zero.
            On the FAT file system, the specified date for both files and directories is correct, but the time of day is always set to midnight.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.ftLastWriteTime">
            <summary>
            A FILETIME structure.
            For a file, the structure specifies when the file was last written to, truncated, or overwritten, for example, when WriteFile or SetEndOfFile are used.The date and time are not updated when file attributes or security descriptors are changed.
            For a directory, the structure specifies when the directory is created.If the underlying file system does not support last write time, this member is zero.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeHigh">
            <summary>
            The high-order DWORD value of the file size, in bytes.
            This value is zero unless the file size is greater than MAXDWORD.
            The size of the file is equal to(nFileSizeHigh* (MAXDWORD+1)) + nFileSizeLow.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.nFileSizeLow">
            <summary>
            The low-order DWORD value of the file size, in bytes.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved0">
            <summary>
            If the dwFileAttributes member includes the FILE_ATTRIBUTE_REPARSE_POINT attribute, this member specifies the reparse point tag.
            Otherwise, this value is undefined and should not be used.
            For more information see Reparse Point Tags.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.dwReserved1">
            <summary>
            Reserved for future use.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cFileName">
            <summary>
            The name of the file.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.WIN32_FIND_DATA.cAlternateFileName">
            <summary>
            An alternative name for the file.
            This name is in the classic 8.3 file name format.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_MODULE_NAME32">
            <summary>
            The maximum length of a name for a process module.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.MAX_PATH">
            <summary>
            The maximum length of file paths for most Win32 functions.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32.INVALID_HANDLE_VALUE">
            <summary>
            Constant for invalid handle value.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)">
            <summary>
            Searches a directory for a file or subdirectory with a name and attributes that match those specified.
            For the most basic version of this function, see FindFirstFile.
            To perform this operation as a transacted operation, use the FindFirstFileTransacted function.
            </summary>
            <param name="lpFileName">
            The directory or path, and the file name, which can include wildcard characters, for example, an asterisk (*) or a question mark (?).
            This parameter should not be NULL, an invalid string (for example, an empty string or a string that is missing the terminating null character), or end in a trailing backslash (\).
            If the string ends with a wildcard, period, or directory name, the user must have access to the root and all subdirectories on the path.
            In the ANSI version of this function, the name is limited to MAX_PATH characters. To extend this limit to approximately 32,000 wide characters, call the Unicode version of the function and prepend "\\?\" to the path. For more information, see Naming a File.
            </param>
            <param name="fInfoLevelId">
            The information level of the returned data.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_INFO_LEVELS"/> enumeration values.
            </param>
            <param name="lpFindFileData">
            A pointer to the buffer that receives the file data.
            The pointer type is determined by the level of information that is specified in the <paramref name="fInfoLevelId"/> parameter.
            </param>
            <param name="fSearchOp">
            The type of filtering to perform that is different from wildcard matching.
            This parameter is one of the <see cref="T:PInvoke.Kernel32.FINDEX_SEARCH_OPS"/> enumeration values.
            </param>
            <param name="lpSearchFilter">
            A pointer to the search criteria if the specified <paramref name="fSearchOp"/> needs structured search information.
            At this time, none of the supported fSearchOp values require extended search information. Therefore, this pointer must be NULL.
            </param>
            <param name="dwAdditionalFlags">Specifies additional flags that control the search.</param>
            <returns>
            If the function succeeds, the return value is a search handle used in a subsequent call to FindNextFile or FindClose, and the lpFindFileData parameter contains information about the first file or directory found.
            If the function fails or fails to locate files from the search string in the lpFileName parameter, the return value is INVALID_HANDLE_VALUE and the contents of lpFindFileData are indeterminate.To get extended error information, call the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="lpBuffer">
            A pointer to a buffer that receives the null-terminated string that specifies the formatted message. If dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER" />, the function allocates a buffer using the LocalAlloc function, and places the pointer to the buffer at the address specified in lpBuffer.
            This buffer cannot be larger than 64K bytes.
            </param>
            <param name="nSize">
            If the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is not set, this parameter specifies the size of the output buffer, in TCHARs. If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> is set,
            this parameter specifies the minimum number of TCHARs to allocate for an output buffer.
            The output buffer cannot be larger than 64K bytes.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentThreadId">
            <summary>
            Retrieves the thread identifier of the calling thread.
            </summary>
            <returns>The thread identifier of the calling thread.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessId">
            <summary>Retrieves the process identifier of the calling process.</summary>
            <returns>The process identifier of the calling process.</returns>
            <remarks>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcessId(System.IntPtr)">
            <summary>
            Retrieves the process identifier of the specified process.
            </summary>
            <param name="Process">A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right. For more information, see Process Security and Access Rights.</param>
            <returns>The process identifier of the specified process.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcess">
            <summary>Retrieves a pseudo handle for the current process.</summary>
            <returns>The return value is a pseudo handle to the current process.</returns>
            <remarks>
                A pseudo handle is a special constant, currently (HANDLE)-1, that is interpreted as the current process handle. For
                compatibility with future operating systems, it is best to call GetCurrentProcess instead of hard-coding this
                constant value. The calling process can use a pseudo handle to specify its own process whenever a process handle is
                required. Pseudo handles are not inherited by child processes.
                <para>This handle has the PROCESS_ALL_ACCESS access right to the process object.</para>
                <para>
                    Windows Server 2003 and Windows XP:  This handle has the maximum access allowed by the security descriptor of
                    the process to the primary token of the process.
                </para>
                <para>
                    A process can create a "real" handle to itself that is valid in the context of other processes, or that can
                    be inherited by other processes, by specifying the pseudo handle as the source handle in a call to the
                    DuplicateHandle function. A process can also use the OpenProcess function to open a real handle to itself.
                </para>
                <para>
                    The pseudo handle need not be closed when it is no longer needed. Calling the <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)" />
                    function with a pseudo handle has no effect.If the pseudo handle is duplicated by DuplicateHandle, the
                    duplicate handle must be closed.
                </para>
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Marks any outstanding I/O operations for the specified file handle. The function only cancels I/O operations
                in the current process, regardless of which thread created the I/O operation.
            </summary>
            <param name="hFile">A handle to the file.</param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> data structure that contains the data used for asynchronous I/O.
                <para>If this parameter is NULL, all I/O requests for the hFile parameter are canceled.</para>
                <para>
                    If this parameter is not NULL, only those specific I/O requests that were issued for the file with the
                    specified
                    <paramref name="lpOverlapped" /> overlapped structure are marked as canceled, meaning that you can cancel one
                    or more requests, while the CancelIo function cancels all outstanding requests on a file handle.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. The cancel operation for all pending I/O operations issued
                by the calling process for the specified file handle was successfully requested. The application must not free or
                reuse the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure associated with the canceled I/O operations until they have
                completed. The thread can use the GetOverlappedResult function to determine when the I/O operations themselves have
                been completed.
                <para>
                    If the function fails, the return value is 0 (zero). To get extended error information, call the
                    <see cref="M:PInvoke.Kernel32.GetLastError" /> function.
                </para>
                <para>
                    If this function cannot find a request to cancel, the return value is 0 (zero), and
                    <see cref="M:PInvoke.Kernel32.GetLastError" />
                    returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_NOT_FOUND" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file
                pointer if supported by the device.
                <para>
                    This function is designed for both synchronous and asynchronous operations. For a similar function designed
                    solely for asynchronous operation, see ReadFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer, tape drive,
                socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
                <para>
                    For asynchronous read operations, hFile can be any handle that is opened with the FILE_FLAG_OVERLAPPED flag
                    by the CreateFile function, or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer that receives the data read from a file or device.
                <para>
                    This buffer must remain valid for the duration of the read operation. The caller must not use this buffer
                    until the read operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <param name="lpNumberOfBytesRead">
                A pointer to the variable that receives the number of bytes read when using a synchronous hFile parameter. ReadFile
                sets this value to zero before doing any work or error checking. Use <see langword="null" /> for this parameter if
                this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be <see langword="null" /> only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise it can be <see langword="null" />.
                <para>
                    If hFile is opened with FILE_FLAG_OVERLAPPED, the <paramref name="lpOverlapped" /> parameter must point to a
                    valid and unique <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure, otherwise the function can incorrectly report that the
                    read operation is complete.
                </para>
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start reading from the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the read operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Writes data to the specified file or input/output (I/O) device.
                <para>
                    This function is designed for both synchronous and asynchronous operation. For a similar function designed
                    solely for asynchronous operation, see WriteFileEx.
                </para>
            </summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
                <para>
                    For asynchronous write operations, hFile can be any handle opened with the CreateFile function using the
                    FILE_FLAG_OVERLAPPED flag or a socket handle returned by the socket or accept function.
                </para>
            </param>
            <param name="lpBuffer">
                A pointer to the buffer containing the data to be written to the file or device.
                <para>
                    This buffer must remain valid for the duration of the write operation. The caller must not use this buffer
                    until the write operation is completed.
                </para>
            </param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <param name="lpNumberOfBytesWritten">
                A pointer to the variable that receives the number of bytes written when using a synchronous hFile parameter.
                WriteFile sets this value to zero before doing any work or error checking. Use <see langword="null" />
                for this parameter if this is an asynchronous operation to avoid potentially erroneous results.
                <para>
                    This parameter can be NULL only when the <paramref name="lpOverlapped" /> parameter is not
                    <see langword="null" />.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure is required if the hFile parameter was opened with
                FILE_FLAG_OVERLAPPED, otherwise this parameter can be NULL.
                <para>
                    For an hFile that supports byte offsets, if you use this parameter you must specify a byte offset at which to
                    start writing to the file or device. This offset is specified by setting the Offset and OffsetHigh members of
                    the <see cref="T:PInvoke.Kernel32.OVERLAPPED" /> structure. For an hFile that does not support byte offsets, Offset and OffsetHigh
                    are ignored.
                </para>
                <para>
                    To write to the end of file, specify both the Offset and OffsetHigh members of the <see cref="T:PInvoke.Kernel32.OVERLAPPED" />
                    structure as 0xFFFFFFFF. This is functionally equivalent to previously calling the CreateFile function to open
                    hFile using FILE_APPEND_DATA access.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is <see langword="true" />.
                <para>
                    If the function fails, or is completing asynchronously, the return value is <see langword="false" />. To get
                    extended error information, call the GetLastError function.
                </para>
                <para>
                    Note: The <see cref="M:PInvoke.Kernel32.GetLastError" /> code <see cref="F:PInvoke.Win32ErrorCode.ERROR_IO_PENDING" /> is not a failure;
                    it designates the write operation is pending completion asynchronously.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetFilePointerEx(PInvoke.Kernel32.SafeObjectHandle,System.Int64,System.Int64@,System.IO.SeekOrigin)">
            <summary>
            Moves the file pointer of the specified file.
            </summary>
            <param name="hFile">
            A handle to the file.
            The file handle must be created with the GENERIC_READ or GENERIC_WRITE access right.
            </param>
            <param name="liDistanceToMove">
            The number of bytes to move the file pointer. A positive value moves the pointer forward in the file and a negative value moves the file pointer backward.
            </param>
            <param name="lpNewFilePointer">
            A pointer to a variable to receive the new file pointer. If this parameter is <see langword="null"/>, the new file pointer is not returned.
            </param>
            <param name="dwMoveMethod">
            The starting point for the file pointer move.
            </param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.
            </returns>
            <seealso href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex"/>
        </member>
        <member name="M:PInvoke.Kernel32.SetFilePointer(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Int32*,System.IO.SeekOrigin)">
            <summary>
            Moves the file pointer of the specified file.
            </summary>
            <param name="hFile">
            A handle to the file.
            </param>
            <param name="lDistanceToMove">
            The low order 32-bits of a signed value that specifies the number of bytes to move the file pointer.
            </param>
            <param name="lpDistanceToMoveHigh">
            A pointer to the high order 32-bits of the signed 64-bit distance to move.
            If you do not need the high order 32-bits, this pointer must be set to <see langword="null"/>.
            When not <see langword="null"/>, this parameter also receives the high order DWORD of the new value of the file pointer.
            </param>
            <param name="dwMoveMethod">
            The starting point for the file pointer move.
            </param>
            <returns>
            <para>
                If the function succeeds and <paramref name="lpDistanceToMoveHigh"/> is <see langword="null"/>,
                the return value is the low-order DWORD of the new file pointer.
                If the function returns a value other than INVALID_SET_FILE_POINTER, the call to <see cref="M:PInvoke.Kernel32.SetFilePointer(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Int32*,System.IO.SeekOrigin)"/> has succeeded.
                You do not need to call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </para>
            <para>
                If function succeeds and <paramref name="lpDistanceToMoveHigh"/> is not <see langword="null"/>, the return value is the low-order DWORD
                of the new file pointer and <paramref name="lpDistanceToMoveHigh "/> contains the high order DWORD of the new file pointer.
            </para>
            <para>
                If the function fails, the return value is INVALID_SET_FILE_POINTER. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </para>
            <para>
                If a new file pointer is a negative value, the function fails, the file pointer is not moved, and the code returned by <see cref="M:PInvoke.Kernel32.GetLastError"/> is ERROR_NEGATIVE_SEEK.
            </para>
            <para>
                If <paramref name="lpDistanceToMoveHigh"/> is <see langword="null"/> and the new file position does not fit in a 32-bit value, the function fails and returns INVALID_SET_FILE_POINTER.
            </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SuspendThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Suspends the specified thread.
            A 64-bit application can suspend a WOW64 thread using the Wow64SuspendThread function (desktop only).
            </summary>
            <param name="hThread">
            A handle to the thread that is to be suspended.
            The handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count; otherwise, it is (DWORD) -1. To get extended error information, use the <see cref="M:PInvoke.Kernel32.GetLastError"/> function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.ResumeThread(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>
            Decrements a thread's suspend count. When the suspend count is decremented to zero, the execution of the thread is resumed.
            </summary>
            <param name="hThread">
            A handle to the thread to be restarted.
            This handle must have the THREAD_SUSPEND_RESUME access right. For more information, see Thread Security and Access Rights.
            </param>
            <returns>
            If the function succeeds, the return value is the thread's previous suspend count.
            If the function fails, the return value is (DWORD) -1. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.WaitForSingleObject(System.Runtime.InteropServices.SafeHandle,System.Int32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses.
            To enter an alertable wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use WaitForMultipleObjects.
            </summary>
            <param name="hHandle">
            A handle to the object. For a list of the object types whose handles can be specified, see the following Remarks section.
            If this handle is closed while the wait is still pending, the function's behavior is undefined.
            The handle must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.
            </param>
            <param name="dwMilliseconds">
            The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the object is signaled or the interval elapses. If dwMilliseconds is zero, the function does not enter a wait state if the object is not signaled; it always returns immediately. If dwMilliseconds is INFINITE, the function will return only when the object is signaled.
            See MSDN docs for more information.
            </param>
            <returns>
            If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.DeviceIoControl(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,PInvoke.Kernel32.OVERLAPPED*)">
            <summary>
                Sends a control code directly to a specified device driver, causing the corresponding device to perform the
                corresponding operation.
            </summary>
            <param name="hDevice">
                A handle to the device on which the operation is to be performed. The device is typically a
                volume, directory, file, or stream. To retrieve a device handle, use the CreateFile function.
            </param>
            <param name="dwIoControlCode">
                The control code for the operation. This value identifies the specific operation to be performed and the type of
                device on which to perform it.
                <para>
                    For a list of the control codes, see Remarks. The documentation for each control code provides usage details
                    for the <paramref name="inBuffer" />, <paramref name="nInBufferSize" />, <paramref name="outBuffer" />, and
                    <paramref name="nOutBufferSize" /> parameters.
                </para>
            </param>
            <param name="inBuffer">
                A pointer to the input buffer that contains the data required to perform the operation. The format of this data
                depends on the value of the <paramref name="dwIoControlCode" /> parameter.
                <para>
                    This parameter can be NULL if <paramref name="dwIoControlCode" /> specifies an operation that does not
                    require input data.
                </para>
            </param>
            <param name="nInBufferSize">The size of the input buffer, in bytes.</param>
            <param name="outBuffer">
                A pointer to the output buffer that is to receive the data returned by the operation. The format of this data
                depends on the value of the <paramref name="dwIoControlCode" /> parameter.
                <para>
                    This parameter can be NULL if <paramref name="dwIoControlCode" /> specifies an operation that does not return
                    data.
                </para>
            </param>
            <param name="nOutBufferSize">The size of the output buffer, in bytes.</param>
            <param name="pBytesReturned">
                A pointer to a variable that receives the size of the data stored in the output buffer, in bytes.
                <para>
                    If the output buffer is too small to receive any data, the call fails, <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_INSUFFICIENT_BUFFER" />, and lpBytesReturned is zero.
                </para>
                <para>
                    If the output buffer is too small to hold all of the data but can hold some entries, some drivers will return
                    as much data as fits. In this case, the call fails, <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_MORE_DATA" />, and lpBytesReturned indicates the amount of data received. Your
                    application should call DeviceIoControl again with the same operation, specifying a new starting point.
                </para>
                <para>
                    If <paramref name="lpOverlapped" /> is NULL, lpBytesReturned cannot be NULL. Even when an operation returns
                    no output data and lpOutBuffer is NULL, DeviceIoControl makes use of lpBytesReturned. After such an operation,
                    the value of lpBytesReturned is meaningless.
                </para>
                <para>
                    If <paramref name="lpOverlapped" /> is not NULL, lpBytesReturned can be NULL. If this parameter is not NULL
                    and the operation returns data, lpBytesReturned is meaningless until the overlapped operation has completed. To
                    retrieve the number of bytes returned, call GetOverlappedResult. If hDevice is associated with an I/O
                    completion port, you can retrieve the number of bytes returned by calling GetQueuedCompletionStatus.
                </para>
            </param>
            <param name="lpOverlapped">
                A pointer to an OVERLAPPED structure.
                <para>
                    If hDevice was opened without specifying <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED" />, lpOverlapped is
                    ignored.
                </para>
                <para>
                    If hDevice was opened with the <see cref="F:PInvoke.Kernel32.CreateFileFlags.FILE_FLAG_OVERLAPPED" /> flag, the operation is
                    performed as an overlapped (asynchronous) operation. In this case, lpOverlapped must point to a valid
                    OVERLAPPED structure that contains a handle to an event object. Otherwise, the function fails in unpredictable
                    ways.
                </para>
                <para>
                    For overlapped operations, DeviceIoControl returns immediately, and the event object is signaled when the
                    operation has been completed. Otherwise, the function does not return until the operation has been completed or
                    an error occurs.
                </para>
            </param>
            <returns>
                If the operation completes successfully, the return value is nonzero.
                <para>
                    If the operation fails or is pending, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FlushFileBuffers(PInvoke.Kernel32.SafeObjectHandle)">
            <summary>Flushes the buffers of a specified file and causes all buffered data to be written to a file.</summary>
            <param name="hFile">
                A handle to the open file.
                <para>
                    The file handle must have the GENERIC_WRITE access right. For more information, see File Security and Access
                    Rights.
                </para>
                <para>If hFile is a handle to a communications device, the function only flushes the transmit buffer.</para>
                <para>
                    If hFile is a handle to the server end of a named pipe, the function does not return until the client has
                    read all buffered data from the pipe.
                </para>
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
                <para>
                    The function fails if hFile is a handle to the console output. That is because the console output is not
                    buffered. The function returns FALSE, and <see cref="M:PInvoke.Kernel32.GetLastError" /> returns
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_INVALID_HANDLE" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,System.String)">
            <summary>
            Creates or opens a named or unnamed mutex object.
            </summary>
            <param name="lpMutexAttributes">
            A pointer to a <see cref="T:PInvoke.Kernel32.SECURITY_ATTRIBUTES"/> structure. If this parameter is NULL, the handle cannot be inherited by child processes.
            The <see cref="F:PInvoke.Kernel32.SECURITY_ATTRIBUTES.lpSecurityDescriptor"/> member of the structure specifies a security descriptor for the new mutex. If <paramref name="lpMutexAttributes"/> is NULL, the mutex gets a default security descriptor. The ACLs in the default security descriptor for a mutex come from the primary or impersonation token of the creator. For more information, see Synchronization Object Security and Access Rights.
            </param>
            <param name="bInitialOwner">
            If this value is TRUE and the caller created the mutex, the calling thread obtains initial ownership of the mutex object. Otherwise, the calling thread does not obtain ownership of the mutex. To determine if the caller created the mutex, see the Return Values section.
            </param>
            <param name="lpName">
            The name of the mutex object. The name is limited to MAX_PATH characters. Name comparison is case sensitive.
            If lpName matches the name of an existing named mutex object, this function requests the MUTEX_ALL_ACCESS access right. In this case, the bInitialOwner parameter is ignored because it has already been set by the creating process. If the lpMutexAttributes parameter is not NULL, it determines whether the handle can be inherited, but its security-descriptor member is ignored.
            If lpName is NULL, the mutex object is created without a name.
            If lpName matches the name of an existing event, semaphore, waitable timer, job, or file-mapping object, the function fails and the GetLastError function returns ERROR_INVALID_HANDLE. This occurs because these objects share the same namespace.
            The name can have a "Global\" or "Local\" prefix to explicitly create the object in the global or session namespace. The remainder of the name can contain any character except the backslash character (\). For more information, see Kernel Object Namespaces. Fast user switching is implemented using Terminal Services sessions. Kernel object names must follow the guidelines outlined for Terminal Services so that applications can support multiple users.
            The object can be created in a private namespace. For more information, see Object Namespaces.
            </param>
            <returns>
            If the function succeeds, the return value is a handle to the newly created mutex object.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            If the mutex is a named mutex and the object existed before this function call, the return value is a handle to the existing object, GetLastError returns ERROR_ALREADY_EXISTS, bInitialOwner is ignored, and the calling thread is not granted ownership. However, if the caller has limited access rights, the function will fail with ERROR_ACCESS_DENIED and the caller should use the OpenMutex function.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcAddress(PInvoke.Kernel32.SafeLibraryHandle,System.String)">
            <summary>
            Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).
            </summary>
            <param name="hModule">A handle to the DLL module that contains the function or variable. The LoadLibrary, LoadLibraryEx, or GetModuleHandle function returns this handle.</param>
            <param name="procName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>
            If the function succeeds, the return value is the address of the exported function or variable.
            If the function fails, the return value is NULL.To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
            <remarks>This function does not retrieve handles for modules that were loaded using the LoadLibraryExFlags.LOAD_LIBRARY_AS_DATAFILE flag.</remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetTickCount">
            <summary>
            Retrieves the number of milliseconds that have elapsed since the system was started, up to 49.7 days.
            </summary>
            <returns>The return value is the number of milliseconds that have elapsed since the system was started.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetTickCount64">
            <summary>
            Retrieves the number of milliseconds that have elapsed since the system was started.
            </summary>
            <returns>The number of milliseconds.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(PInvoke.Kernel32.SYSTEMTIME*)">
            <summary>
            Retrieves the current system date and time. The system time is expressed in Coordinated Universal Time (UTC).
            To retrieve the current system date and time in local time, use the GetLocalTime function.
            </summary>
            <param name="lpSystemTime">
            A pointer to a SYSTEMTIME structure to receive the current system date and time.
            The lpSystemTime parameter must not be NULL. Using NULL will result in an access violation.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.SetLastError(System.UInt32)">
            <summary>
            Sets the last-error code for the calling thread.
            </summary>
            <param name="dwErrCode">The last-error code for the thread.</param>
        </member>
        <member name="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)">
            <summary>
            Sets the bits of a 64-bit value to indicate the comparison operator to use for a specified operating system version
            attribute. This function is used to build the dwlConditionMask parameter of the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            </summary>
            <param name="ConditionMask">A value to be passed as the dwlConditionMask parameter of the <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.
            The function stores the comparison information in the bits of this variable. Before the first call to <see cref="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/>,
            initialize this variable to zero. For subsequent calls, pass in the variable used in the previous call.</param>
            <param name="TypeMask">A mask that indicates the member of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure whose comparison operator
            is being set. This value corresponds to one of the bits specified in the dwTypeMask parameter for the
            <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function.</param>
            <param name="Condition">The operator to be used for the comparison. The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function uses this
            operator to compare a specified attribute value to the corresponding value for the currently running system.</param>
            <returns>The function returns the condition mask value.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)">
             <summary>
             Compares a set of operating system version requirements to the corresponding values for the currently
             running version of the system.This function is subject to manifest-based behavior.
             </summary>
             <param name="lpVersionInformation">
             A pointer to an OSVERSIONINFOEX structure containing the operating system version requirements to compare. The <paramref name="dwTypeMask"/>
             parameter indicates the members of this structure that contain information to compare. You must set the
             <see cref="F:PInvoke.Kernel32.OSVERSIONINFOEX.dwOSVersionInfoSize"/> member of this structure to <code>Marshal.SizeOf(typeof(OSVERSIONINFOEX))</code>
             or create it with <see cref="M:PInvoke.Kernel32.OSVERSIONINFOEX.Create"/>. You must
             also specify valid data for the members indicated by <paramref name="dwTypeMask"/>. The function ignores structure members for which the
             corresponding <paramref name="dwTypeMask"/> bit is not set.
             </param>
             <param name="dwTypeMask">A mask that indicates the members of the <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> structure to be tested.</param>
             <param name="dwlConditionMask">The type of comparison to be used for each <paramref name="lpVersionInformation"/> member being compared. To build this value,
             call the <see cref="M:PInvoke.Kernel32.VerSetConditionMask(System.Int64,PInvoke.Kernel32.VER_MASK,PInvoke.Kernel32.VER_CONDITION)"/> function once for each <see cref="T:PInvoke.Kernel32.OSVERSIONINFOEX"/> member being compared.</param>
             <returns>
             <para>
             If the currently running operating system satisfies the specified requirements, the return value is a nonzero value.
             </para>
             <para>
             If the current system does not satisfy the requirements, the return value is zero and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns <see cref="F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             <para>
             If the function fails, the return value is zero and <see cref="M:PInvoke.Kernel32.GetLastError"/> returns an error code other than <see cref="F:PInvoke.Win32ErrorCode.ERROR_OLD_WIN_VERSION"/>.
             </para>
             </returns>
             <remarks>
             <para>
             The <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> function retrieves version information about the currently running operating system and compares it to the valid
             members of the <paramref name="lpVersionInformation"/> structure. This enables you to easily determine the presence of a required set of
             operating system version conditions. It is preferable to use <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> rather than
             calling the GetVersionEx function to perform your own comparisons.
             </para>
             <para>
             Typically, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns a nonzero value only if all specified tests succeed.
             However, major, minor, and service pack versions are tested in a hierarchical manner because the operating system version is a combination of
             these values. If a condition exists for the major version, it supersedes the conditions specified for minor version and service pack version.
             (You cannot test for major version greater than 5 and minor version less than or equal to 1. If you specify such a test, the function will
             change the request to test for a minor version greater than 1 because it is performing a greater than operation on the major version.)
             </para>
             <para>
             The function tests these values in this order: major version, minor version, and service pack version.The function continues testing values while
             they are equal, and stops when one of the values does not meet the specified condition.For example, if you test for a system greater than or
             equal to version 5.1 service pack 1, the test succeeds if the current version is 6.0. (The major version is greater than the specified version,
             so the testing stops.) In the same way, if you test for a system greater than or equal to version 5.1 service pack 1, the test succeeds if the
             current version is 5.2. (The minor version is greater than the specified versions, so the testing stops.) However, if you test for a system greater
             than or equal to version 5.1 service pack 1, the test fails if the current version is 5.0 service pack 2. (The minor version is not greater than
             the specified version, so the testing stops.)
             </para>
             <para>
             To verify a range of system versions, you must call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> twice.For example, to verify
             that the system version is greater than 5.0 but less than or equal to 5.1, first call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> to
             test that the major version is 5 and the minor version is greater than 0, then call <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
             again to test that the major version is 5 and the minor version is less than or equal to 1.
             </para>
             <para>
             Identifying the current operating system is usually not the best way to determine whether a particular operating system feature is present.
             This is because the operating system may have had new features added in a redistributable DLL. Rather than using GetVersionEx to determine the operating
             system platform or version number, test for the presence of the feature itself.
             </para>
             <para>
             To verify whether the current operating system is either the Media Center or Tablet PC version of Windows, call GetSystemMetrics.
             </para>
             <para>
             Windows 10:
                 <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> returns false when called by applications that do not have a
                 compatibility manifest for Windows 8.1 or Windows 10 if the <paramref name="lpVersionInformation"/> parameter is set so that it specifies
                 Windows 8.1 or Windows 10, even when the current operating system version is Windows 8.1 or Windows 10. Specifically,
                 <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> has the following behavior:
            
                 If the application has no manifest, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/> behaves as
                     if the operation system version is Windows 8 (6.2).
                 If the application has a manifest that contains the GUID that corresponds to Windows 8.1, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 8.1 (6.3).
                 If the application has a manifest that contains the GUID that corresponds to Windows 10, <see cref="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
                     behaves as if the operation system version is Windows 10 (10.0).
             </para>
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FileTimeToSystemTime(PInvoke.Kernel32.FILETIME*,PInvoke.Kernel32.SYSTEMTIME*)">
            <summary>
            Converts a file time to system time format. System time is based on Coordinated Universal Time (UTC).
            </summary>
            <param name="lpFileTime">
            A pointer to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure containing the file time to be converted to system (UTC) date and time format.
            This value must be less than 0x8000000000000000. Otherwise, the function fails.
            </param>
            <param name="lpSystemTime">A pointer to a <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure to receive the converted file time.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SystemTimeToFileTime(PInvoke.Kernel32.SYSTEMTIME*,PInvoke.Kernel32.FILETIME*)">
            <summary>
            Converts a system time to file time format. System time is based on Coordinated Universal Time (UTC).
            </summary>
            <param name="lpSystemTime">
            A pointer to a <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure that contains the system time to be converted from UTC to file time format.
            The <see cref="F:PInvoke.Kernel32.SYSTEMTIME.wDayOfWeek"/> member of the <see cref="T:PInvoke.Kernel32.SYSTEMTIME"/> structure is ignored.
            </param>
            <param name="lpFileTime">A pointer to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure to receive the converted system time.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.CompareFileTime(PInvoke.Kernel32.FILETIME*,PInvoke.Kernel32.FILETIME*)">
            <summary>
            Compares two file times.
            </summary>
            <param name="lpFileTime1">A pointer to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure that specifies the first file time.</param>
            <param name="lpFileTime2">A pointer to a <see cref="T:PInvoke.Kernel32.FILETIME"/> structure that specifies the second file time.</param>
            <returns>
            The return value is one of the following values.
            -1: First file time is earlier than second file time.
            0: First file time is equal to second file time.
            1: First file time is later than second file time.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetErrorMode(PInvoke.Kernel32.ErrorModes)">
            <summary>
                Controls whether the system will handle the specified types of serious errors or whether the process will handle them.
            </summary>
            <param name="uMode">The process error mode.</param>
            <returns>
                The return value is the previous state of the error-mode bit flags.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetVolumeInformation(System.String,System.Char*,System.Int32,System.UInt32@,System.Int32@,PInvoke.Kernel32.FileSystemFlags@,System.Char*,System.Int32)">
            <summary>
            Retrieves information about the file system and volume associated with the specified root directory.
            </summary>
            <param name="lpRootPathName">
            <para>
            A pointer to a string that contains the root directory of the volume to be described.
            </para>
            <para>
            If this parameter is NULL, the root of the current directory is used. A trailing backslash is required.
            For example, you specify <c>\\MyServer\MyShare</c> as <c>"\\MyServer\MyShare\"</c>, or the C drive as
            <c>"C:\"</c>.
            </para>
            </param>
            <param name="lpVolumeNameBuffer">
            A pointer to a buffer that receives the name of a specified volume. The buffer size is specified by the <paramref name="nVolumeNameSize"/> parameter.
            </param>
            <param name="nVolumeNameSize">
            The length of a volume name buffer, in TCHARs. The maximum buffer size is MAX_PATH+1.
            This parameter is ignored if the volume name buffer is not supplied.
            </param>
            <param name="lpVolumeSerialNumber">
            <para>
            A pointer to a variable that receives the volume serial number.
            </para>
            <para>
            This parameter can be NULL if the serial number is not required.
            </para>
            <para>
            This function returns the volume serial number that the operating system assigns when a hard disk i
            formatted. To programmatically obtain the hard disk's serial number that the manufacturer assigns, use
            the Windows Management Instrumentation (WMI) Win32_PhysicalMedia property SerialNumber.
            </para>
            </param>
            <param name="lpMaximumComponentLength">
            <para>
            A pointer to a variable that receives the maximum length, in TCHARs, of a file name component that a specified file system supports.
            </para>
            <para>
            A file name component is the portion of a file name between backslashes.
            </para>
            <para>
            The value that is stored in the variable that *lpMaximumComponentLength points to is used to indicate
            that a specified file system supports long names. For example, for a FAT file system that supports long
            names, the function stores the value 255, rather than the previous 8.3 indicator. Long names can also be
            supported on systems that use the NTFS file system.
            </para>
            </param>
            <param name="lpFileSystemFlags">
            A pointer to a variable that receives flags associated with the specified file system.
            </param>
            <param name="lpFileSystemNameBuffer">
            A pointer to a buffer that receives the name of the file system, for example, the FAT file system or
            the NTFS file system. The buffer size is specified by the <paramref name="nFileSystemNameSize" /> parameter.
            </param>
            <param name="nFileSystemNameSize">
            <para>
            The length of the file system name buffer, in TCHARs. The maximum buffer size is MAX_PATH+1.
            </para>
            <para>
            This parameter is ignored if the file system name buffer is not supplied.
            </para>
            </param>
            <returns>
            If all the requested information is retrieved, the return value is nonzero.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FlushInstructionCache(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.UIntPtr)">
            <summary>
            Flushes the instruction cache for the specified process.
            </summary>
            <param name="hProcess">A handle to a process whose instruction cache is to be flushed.</param>
            <param name="lpcBaseAddress">A pointer to the base of the region to be flushed. This parameter can be null.</param>
            <param name="dwSize">The size of the region to be flushed if the <paramref name="lpcBaseAddress"/> parameter is not null, in bytes.</param>
            <returns>
            If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
            </returns>
            <remarks>
            Applications should call <see cref="M:PInvoke.Kernel32.FlushInstructionCache(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.UIntPtr)"/> if they generate or modify code in memory.
            The CPU cannot detect the change, and may execute the old code it cached.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FlushProcessWriteBuffers">
            <summary>
            Flushes the write queue of each processor that is running a thread of the current process.
            </summary>
            <remarks>
            The function generates an interprocessor interrupt (IPI) to all processors that are part of the current process affinity.
            It guarantees the visibility of write operations performed on one processor to the other processors.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessorNumber">
            <summary>
            Retrieves the number of the processor the current thread was running on during the call to this function.
            </summary>
            <returns>The function returns the current processor number.</returns>
            <remarks>
            This function is used to provide information for estimating process performance.
            On systems with more than 64 logical processors, the <see cref="M:PInvoke.Kernel32.GetCurrentProcessorNumber"/> function returns the processor number within the processor
            group to which the logical processor is assigned.Use the <see cref="M:PInvoke.Kernel32.GetCurrentProcessorNumberEx(PInvoke.Kernel32.PROCESSOR_NUMBER*)"/> function to retrieve the processor group and number of the
            current processor.
            </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessorNumberEx(PInvoke.Kernel32.PROCESSOR_NUMBER*)">
             <summary>
             Retrieves the processor group and number of the logical processor in which the calling thread is running.
             </summary>
             <param name="ProcNumber">
             A pointer to a <see cref="T:PInvoke.Kernel32.PROCESSOR_NUMBER"/> structure that receives the processor group to which the logical
             processor is assigned and the number of the logical processor within its group.
             </param>
             <remarks>
             If the function succeeds, the <paramref name="ProcNumber"/> parameter contains the group and processor number of the processor on which
             the calling thread is running.
            
             To compile an application that uses this function in C/C++, set _WIN32_WINNT >= 0x0601. This corresponds to a min. platform target
             of Windows 7/Windows Server 2008 R2 for this function to be available.
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentThread">
             <summary>
             Retrieves a pseudo handle for the calling thread.
             </summary>
             <returns>The return value is a pseudo handle for the current thread.</returns>
             <remarks>
             A pseudo handle is a special constant that is interpreted as the current thread handle. The calling thread can use this handle to specify itself
             whenever a thread handle is required. Pseudo handles are not inherited by child processes.
            
             This handle has the THREAD_ALL_ACCESS access right to the thread object.
            
             Windows Server 2003 and Windows XP:  This handle has the maximum access allowed by the security descriptor of the thread to the primary token of
             the process.
            
             The function cannot be used by one thread to create a handle that can be used by other threads to refer to the first thread.The handle is always
             interpreted as referring to the thread that is using it.A thread can create a "real" handle to itself that can be used by other threads, or
             inherited by other processes, by specifying the pseudo handle as the source handle in a call to the DuplicateHandle function.
            
             The pseudo handle need not be closed when it is no longer needed.Calling the <see cref="M:PInvoke.Kernel32.CloseHandle(System.IntPtr)"/> function with this handle has no effect. If the pseudo
             handle is duplicated by DuplicateHandle, the duplicate handle must be closed.
            
             Do not create a thread while impersonating a security context. The call will succeed, however the newly created thread will have reduced access
             rights to itself when calling GetCurrentThread.The access rights granted this thread will be derived from the access rights the impersonated user
             has to the process.Some access rights including THREAD_SET_THREAD_TOKEN and THREAD_GET_CONTEXT may not be present, leading to unexpected failures.
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentThreadStackLimits(System.UIntPtr@,System.UIntPtr@)">
             <summary>
             Retrieves the boundaries of the stack that was allocated by the system for the current thread.
             </summary>
             <param name="LowLimit">A pointer variable that receives the lower boundary of the current thread stack.</param>
             <param name="HighLimit">A pointer variable that receives the upper boundary of the current thread stack.</param>
             <remarks>
             It is possible for user-mode code to execute in stack memory that is outside the region allocated by the system when the thread was created.
             Callers can use the GetCurrentThreadStackLimits function to verify that the current stack pointer is within the returned limits.
            
             To compile an application (C, C++) that uses this function, set _WIN32_WINNT >= 0x0602. This corresponds to a min. platform
             requirement of Windows 8/Windows Server 2012 for using this function.
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetPriorityClass(PInvoke.Kernel32.SafeObjectHandle)">
             <summary>
             Retrieves the priority class for the specified process. This value, together with the priority value of each thread of the process,
             determines each thread's base priority level.
             </summary>
             <param name="hProcess">
             A handle to the process.
            
             The handle must have the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION"/> or <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_LIMITED_INFORMATION"/> access
             right.For more information,see  <a href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.
            
             Windows Server 2003 and Windows XP:  The handle must have the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_QUERY_INFORMATION"/> access right.
             </param>
             <returns>
             If the function succeeds, the return value is the priority class of the specified process.
            
             If the function fails, the return value is zero.To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
             </returns>
             <remarks>
             Every thread has a base priority level determined by the thread's priority value and the priority class of its process. The operating system
             uses the base priority level of all executable threads to determine which thread gets the next slice of CPU time. Threads are scheduled in a
             round-robin fashion at each priority level, and only when there are no executable threads at a higher level will scheduling of threads at a
             lower level take place.
            
             For a table that shows the base priority levels for each combination of priority class and thread priority value, see
             <a href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/scheduling-priorities">Scheduling Priorities</a>
            
             Priority class is maintained by the executive, so all processes have a priority class that can be queried.
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.GetNativeSystemInfo(PInvoke.Kernel32.SYSTEM_INFO*)">
            <summary>
            Retrieves information about the current system.
            </summary>
            <param name="lpSystemInfo">
            A pointer to a <see cref="T:PInvoke.Kernel32.SYSTEM_INFO"/> structure that receives the information.
            </param>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.Void*,System.UInt32)">
             <summary>
             Retrieves information about the specified process.
             </summary>
             <param name="hProcess">
             A handle to the process. This handle must have the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SET_INFORMATION"/> access right.
             For more information, see <a href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</a>.
             </param>
             <param name="ProcessInformationClass">
             A member of the <see cref="T:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS"/> enumeration specifying the kind of information to retrieve.
             </param>
             <param name="ProcessInformation">
             Pointer to an object to receive the type of information specified by the <paramref name="ProcessInformationClass"/> parameter.
             </param>
             <param name="ProcessInformationSize">
             The size in bytes of the structure specified by the <paramref name="ProcessInformation"/> parameter.
            
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessMemoryPriority"/>,
             this parameter must be <code>sizeof(<see cref="T:PInvoke.Kernel32.MEMORY_PRIORITY_INFORMATION"/>)</code>
            
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessPowerThrottling"/>,
             this parameter must be <code>sizeof(<see cref="T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE"/>)</code>
            
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessProtectionLevelInfo"/>,
             this parameter must be <code>sizeof(<see cref="T:PInvoke.Kernel32.PROCESS_PROTECTION_LEVEL_INFORMATION"/>)</code>
            
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessLeapSecondInfo"/>,
             this parameter must be <code>sizeof(<see cref="T:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO"/>)</code>
            
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessAppMemoryInfo"/>,
             this parameter must be <code>sizeof(<see cref="T:PInvoke.Kernel32.APP_MEMORY_INFORMATION"/>)</code>
             </param>
             <returns>
             If the function succeeds, the return value is nonzero.
            
             If the function fails, the return value is zero.To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
             </returns>
        </member>
        <member name="M:PInvoke.Kernel32.SetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.Void*,System.UInt32)">
             <summary>
             Sets information for the specified process.
             </summary>
             <param name="hProcess">
             A handle to the process. This handle must have the <see cref="F:PInvoke.Kernel32.ProcessAccess.PROCESS_SET_INFORMATION"/> access right.
            
             For more information, see <see href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/process-security-and-access-rights">Process Security and Access Rights</see>.
             </param>
             <param name="ProcessInformationClass">Specifies the kind of information to be set.</param>
             <param name="ProcessInformation">
             Pointer to an object that contains the type of information specified by the <paramref name="ProcessInformationClass"/>
             parameter
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessMemoryPriority"/>, this
             parameter must point to a <see cref="T:PInvoke.Kernel32.MEMORY_PRIORITY_INFORMATION"/> structure.
            
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessPowerThrottling"/>, this
             parameter must point to a <see cref="T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE"/> structure.
            
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessLeapSecondInfo"/>, this
             parameter must point to a <see cref="T:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO"/> structure.
             </param>
             <param name="ProcessInformationSize">
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessMemoryPriority"/>, this
             parameter must be <code>sizeof(<see cref="T:PInvoke.Kernel32.MEMORY_PRIORITY_INFORMATION"/>)</code>.
            
             If <paramref name="ProcessInformationClass"/> is  <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessPowerThrottling"/>, this
             parameter must be <code>sizeof(<see cref="T:PInvoke.Kernel32.PROCESS_POWER_THROTTLING_STATE"/>)</code>
            
             If <paramref name="ProcessInformationClass"/> is <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessLeapSecondInfo"/>, this
             parameter must be <code>sizeof(<see cref="T:PInvoke.Kernel32.PROCESS_LEAP_SECOND_INFO"/>)</code>
             </param>
             <returns>
             If the function succeeds, the return value is nonzero.
            
             If the function fails, the return value is zero.To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
             </returns>
             <remarks>
             To help improve system performance, applications should use the SetProcessInformation function with
             <see cref="F:PInvoke.Kernel32.PROCESS_INFORMATION_CLASS.ProcessMemoryPriority"/> to lower the default memory priority of threads that perform
             background operations or access files and data that are not expected to be accessed again soon. For example, a file indexing
             application might set a lower default priority for the process that performs the indexing task.
            
             Memory priority helps to determine how long pages remain in the working set of a process before they are trimmed.A process's
             memory priority determines the default priority of the physical pages that are added to the process working set by the threads
             of that process. When the memory manager trims the working set, it trims lower priority pages before higher priority pages.
             This improves overall system performance because higher priority pages are less likely to be trimmed from the working set and
             then trigger a page fault when they are accessed again.
             </remarks>
        </member>
        <member name="M:PInvoke.Kernel32.FindClose(System.IntPtr)">
            <summary>
                Closes a file search handle opened by the FindFirstFile, FindFirstFileEx, FindFirstFileNameW,
                FindFirstFileNameTransactedW, FindFirstFileTransacted, FindFirstStreamTransactedW, or FindFirstStreamW functions.
            </summary>
            <param name="hFindFile">The file search handle.</param>
            <returns>
                If the function succeeds, the return value is nonzero.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FreeLibrary(System.IntPtr)">
            <summary>
                Frees the loaded dynamic-link library (DLL) module and, if necessary, decrements its reference count. When the
                reference count reaches zero, the module is unloaded from the address space of the calling process and the handle
                is no longer valid.
            </summary>
            <param name="hModule">
                A handle to the loaded library module. The LoadLibrary, LoadLibraryEx, GetModuleHandle, or
                GetModuleHandleEx function returns this handle.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value.
                <para>
                    If the function fails, the return value is zero. To get extended error information, call
                    <see cref="M:PInvoke.Kernel32.GetLastError" />.
                </para>
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <summary>
            Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
            </summary>
            <param name="dwFlags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            The <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ARGUMENT_ARRAY"/> flag is always added
            and the <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_ALLOCATE_BUFFER"/> flag is always suppressed by this helper method.
            </param>
            <param name="lpSource">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="dwFlags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="dwMessageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="dwLanguageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="Arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="maxAllowedBufferSize">The maximum size of the returned string. If exceeded, <c>null</c> is returned.</param>
            <returns>
            If the function succeeds, the return value is the number of TCHARs stored in the output buffer, excluding the terminating null character.
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:PInvoke.Kernel32.GetLastError"/>.
            </returns>
        </member>
        <member name="M:PInvoke.Kernel32.GetLastError">
            <summary>
                Returns the error code returned by the last unmanaged function that was called using platform invoke that has
                the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> flag set.
            </summary>
            <returns>
                The last error code set by a call to the Win32 SetLastError function.
                <para>
                    The Return Value section of the documentation for each function that sets the last-error code notes the
                    conditions under which the function sets the last-error code. Most functions that set the thread's last-error
                    code set it when they fail. However, some functions also set the last-error code when they succeed. If the
                    function is not documented to set the last-error code, the value returned by this function is simply the most
                    recent last-error code to have been set; some functions set the last-error code to
                    <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS" /> on success and others do not.
                </para>
            </returns>
            <remarks>
                This method exists because it is not safe to make a direct platform invoke call to GetLastError to obtain this
                information. If you want to access this error code, you must call <see cref="M:PInvoke.Kernel32.GetLastError" /> instead of writing
                your own platform invoke definition for GetLastError and calling it. The common language runtime can make internal
                calls to APIs that overwrite the GetLastError maintained by the operating system.
                <para>
                    You can use this method to obtain error codes only if you apply the <see cref="T:System.Runtime.InteropServices.DllImportAttribute" /> to the
                    method signature and set the <see cref="F:System.Runtime.InteropServices.DllImportAttribute.SetLastError" /> field to true. The process for this
                    varies depending upon the source language used: C# and C++ are false by default, but the Declare statement in
                    Visual Basic is true.
                </para>
            </remarks>
            <devremarks>
                See
                https://stackoverflow.com/questions/17918266/winapi-getlasterror-vs-marshal-getlastwin32error/17918729#17918729 for
                more details.
            </devremarks>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">A pointer to the buffer containing the data to be written to the file or device.</param>
            <param name="nNumberOfBytesToWrite">
                The number of bytes to be written to the file or device.
                <para>
                    A value of zero specifies a null write operation. The behavior of a null write operation depends on the
                    underlying file system or communications technology.
                </para>
            </param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Writes data synchronously to the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the file or I/O device (for example, a file, file stream, physical disk, volume, console buffer, tape
                drive, socket, communications resource, mailslot, or pipe).
                <para>
                    The hFile parameter must have been created with the write access. For more information, see Generic Access
                    Rights and File Security and Access Rights.
                </para>
            </param>
            <param name="lpBuffer">The buffer containing the data to be written to the file or device.</param>
            <returns>The number of bytes written.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Write failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A pointer to the buffer that receives the data read from a file or device.</param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.ArraySegment{System.Byte})">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="lpBuffer">A buffer that receives the data read from a file or device.</param>
            <returns>The number of bytes read.</returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Int32)">
            <summary>Reads data synchronously from the specified file or input/output (I/O) device.</summary>
            <param name="hFile">
                A handle to the device (for example, a file, file stream, physical disk, volume, console buffer,
                tape drive, socket, communications resource, mailslot, or pipe).
                <para>The hFile parameter must have been created with read access.</para>
            </param>
            <param name="nNumberOfBytesToRead">The maximum number of bytes to be read.</param>
            <returns>
                The data that has been read. The segment returned might have a size smaller than
                <paramref name="nNumberOfBytesToRead" /> if less bytes than requested have been read.
            </returns>
            <exception cref="T:PInvoke.Win32Exception">Thrown if the native method return false (Read failed).</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="hFile" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,System.Threading.NativeOverlapped*)">
            <inheritdoc cref="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)" />
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,System.Threading.NativeOverlapped*)">
            <inheritdoc cref="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,System.Threading.NativeOverlapped*)">
            <inheritdoc cref="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.DeviceIoControl(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,System.Threading.NativeOverlapped*)">
            <inheritdoc cref="M:PInvoke.Kernel32.DeviceIoControl(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <summary>
            Tries to get the error message text using the supplied buffer.
            </summary>
            <param name="flags">
            The formatting options, and how to interpret the lpSource parameter. The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer. The low-order byte can also specify the maximum width of a formatted output line.
            </param>
            <param name="source">
            The location of the message definition. The type of this parameter depends upon the settings in the <paramref name="flags"/> parameter.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_HMODULE"/>: A handle to the module that contains the message table to search.
            If <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>: Pointer to a string that consists of unformatted message text. It will be scanned for inserts and formatted accordingly.
            If neither of these flags is set in dwFlags, then lpSource is ignored.
            </param>
            <param name="messageId">
            The message identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING" />.
            </param>
            <param name="languageId">
            The language identifier for the requested message. This parameter is ignored if dwFlags includes <see cref="F:PInvoke.Kernel32.FormatMessageFlags.FORMAT_MESSAGE_FROM_STRING"/>.
            If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:
            Language neutral
            Thread LANGID, based on the thread's locale value
            User default LANGID, based on the user's default locale value
            System default LANGID, based on the system default locale value
            US English
            If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message string that is present.If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.
            </param>
            <param name="sb">The buffer to use for acquiring the message.</param>
            <param name="arguments">
            An array of values that are used as insert values in the formatted message. A %1 in the format string indicates the first value in the Arguments array; a %2 indicates the second argument; and so on.
            The interpretation of each value depends on the formatting information associated with the insert in the message definition.The default is to treat each value as a pointer to a null-terminated string.
            By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific data type for describing a variable number of arguments.The state of the va_list argument is undefined upon return from the function.To use the va_list again, destroy the variable argument list pointer using va_end and reinitialize it with va_start.
            If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted as the insert values.Each insert must have a corresponding element in the array.
            </param>
            <param name="errorMsg">Receives the resulting error message.</param>
            <returns><c>true</c> if the attempt is successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.IntPtr,PInvoke.Kernel32.FindFirstFileExFlags)">
            <inheritdoc cref = "M:PInvoke.Kernel32.FindFirstFileEx(System.String,PInvoke.Kernel32.FINDEX_INFO_LEVELS,PInvoke.Kernel32.WIN32_FIND_DATA@,PInvoke.Kernel32.FINDEX_SEARCH_OPS,System.Void*,PInvoke.Kernel32.FindFirstFileExFlags)"/>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])">
            <inheritdoc cref = "M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.Int32,System.IntPtr[])"/>
        </member>
        <member name="M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.CancelIoEx(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <inheritdoc cref = "M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32,System.Nullable{System.Int32}@,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Nullable{System.Int32}@,PInvoke.Kernel32.OVERLAPPED*)">
            <inheritdoc cref = "M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32,System.Int32*,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.SetFilePointer(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.IntPtr,System.IO.SeekOrigin)">
            <inheritdoc cref = "M:PInvoke.Kernel32.SetFilePointer(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Int32*,System.IO.SeekOrigin)"/>
        </member>
        <member name="M:PInvoke.Kernel32.SetFilePointer(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Nullable{System.Int32}@,System.IO.SeekOrigin)">
            <inheritdoc cref = "M:PInvoke.Kernel32.SetFilePointer(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Int32*,System.IO.SeekOrigin)"/>
        </member>
        <member name="M:PInvoke.Kernel32.DeviceIoControl(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.DeviceIoControl(PInvoke.Kernel32.SafeObjectHandle,System.Int32,System.Void*,System.Int32,System.Void*,System.Int32,System.Int32@,PInvoke.Kernel32.OVERLAPPED*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(System.IntPtr,System.Boolean,System.String)">
            <inheritdoc cref = "M:PInvoke.Kernel32.CreateMutex(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,System.String)"/>
        </member>
        <member name="M:PInvoke.Kernel32.CreateMutex(System.Nullable{PInvoke.Kernel32.SECURITY_ATTRIBUTES},System.Boolean,System.String)">
            <inheritdoc cref = "M:PInvoke.Kernel32.CreateMutex(PInvoke.Kernel32.SECURITY_ATTRIBUTES*,System.Boolean,System.String)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetSystemTime(PInvoke.Kernel32.SYSTEMTIME*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetSystemTime(PInvoke.Kernel32.SYSTEMTIME@)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetSystemTime(PInvoke.Kernel32.SYSTEMTIME*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(System.IntPtr,PInvoke.Kernel32.VER_MASK,System.Int64)">
            <inheritdoc cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
        </member>
        <member name="M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX@,PInvoke.Kernel32.VER_MASK,System.Int64)">
            <inheritdoc cref = "M:PInvoke.Kernel32.VerifyVersionInfo(PInvoke.Kernel32.OSVERSIONINFOEX*,PInvoke.Kernel32.VER_MASK,System.Int64)"/>
        </member>
        <member name="M:PInvoke.Kernel32.FileTimeToSystemTime(System.IntPtr,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.FileTimeToSystemTime(PInvoke.Kernel32.FILETIME*,PInvoke.Kernel32.SYSTEMTIME*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.FileTimeToSystemTime(PInvoke.Kernel32.FILETIME,PInvoke.Kernel32.SYSTEMTIME@)">
            <inheritdoc cref = "M:PInvoke.Kernel32.FileTimeToSystemTime(PInvoke.Kernel32.FILETIME*,PInvoke.Kernel32.SYSTEMTIME*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.SystemTimeToFileTime(System.IntPtr,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.SystemTimeToFileTime(PInvoke.Kernel32.SYSTEMTIME*,PInvoke.Kernel32.FILETIME*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.SystemTimeToFileTime(PInvoke.Kernel32.SYSTEMTIME,PInvoke.Kernel32.FILETIME@)">
            <inheritdoc cref = "M:PInvoke.Kernel32.SystemTimeToFileTime(PInvoke.Kernel32.SYSTEMTIME*,PInvoke.Kernel32.FILETIME*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.CompareFileTime(System.IntPtr,System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.CompareFileTime(PInvoke.Kernel32.FILETIME*,PInvoke.Kernel32.FILETIME*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.CompareFileTime(PInvoke.Kernel32.FILETIME,PInvoke.Kernel32.FILETIME)">
            <inheritdoc cref = "M:PInvoke.Kernel32.CompareFileTime(PInvoke.Kernel32.FILETIME*,PInvoke.Kernel32.FILETIME*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetVolumeInformation(System.String,System.IntPtr,System.Int32,System.UInt32@,System.Int32@,PInvoke.Kernel32.FileSystemFlags@,System.IntPtr,System.Int32)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetVolumeInformation(System.String,System.Char*,System.Int32,System.UInt32@,System.Int32@,PInvoke.Kernel32.FileSystemFlags@,System.Char*,System.Int32)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetVolumeInformation(System.String,System.Span{System.Char},System.UInt32@,System.Int32@,PInvoke.Kernel32.FileSystemFlags@,System.Span{System.Char})">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetVolumeInformation(System.String,System.Char*,System.Int32,System.UInt32@,System.Int32@,PInvoke.Kernel32.FileSystemFlags@,System.Char*,System.Int32)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetVolumeInformation(System.String,System.Char[],System.Int32,System.UInt32@,System.Int32@,PInvoke.Kernel32.FileSystemFlags@,System.Char[],System.Int32)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetVolumeInformation(System.String,System.Char*,System.Int32,System.UInt32@,System.Int32@,PInvoke.Kernel32.FileSystemFlags@,System.Char*,System.Int32)"/>
        </member>
        <member name="M:PInvoke.Kernel32.FlushInstructionCache(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.UIntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.FlushInstructionCache(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.UIntPtr)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessorNumberEx(System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetCurrentProcessorNumberEx(PInvoke.Kernel32.PROCESSOR_NUMBER*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetCurrentProcessorNumberEx(PInvoke.Kernel32.PROCESSOR_NUMBER@)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetCurrentProcessorNumberEx(PInvoke.Kernel32.PROCESSOR_NUMBER*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetNativeSystemInfo(System.IntPtr)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetNativeSystemInfo(PInvoke.Kernel32.SYSTEM_INFO*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetNativeSystemInfo(PInvoke.Kernel32.SYSTEM_INFO@)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetNativeSystemInfo(PInvoke.Kernel32.SYSTEM_INFO*)"/>
        </member>
        <member name="M:PInvoke.Kernel32.GetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.IntPtr,System.UInt32)">
            <inheritdoc cref = "M:PInvoke.Kernel32.GetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.Void*,System.UInt32)"/>
        </member>
        <member name="M:PInvoke.Kernel32.SetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.IntPtr,System.UInt32)">
            <inheritdoc cref = "M:PInvoke.Kernel32.SetProcessInformation(PInvoke.Kernel32.SafeObjectHandle,PInvoke.Kernel32.PROCESS_INFORMATION_CLASS,System.Void*,System.UInt32)"/>
        </member>
        <member name="M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.IntPtr[],System.Int32)">
            <inheritdoc cref = "M:PInvoke.Kernel32.FormatMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.IntPtr[],System.Int32)"/>
        </member>
        <member name="M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <inheritdoc cref = "M:PInvoke.Kernel32.WriteFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/>
        </member>
        <member name="M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.IntPtr,System.Int32)">
            <inheritdoc cref = "M:PInvoke.Kernel32.ReadFile(PInvoke.Kernel32.SafeObjectHandle,System.Void*,System.Int32)"/>
        </member>
        <member name="M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.IntPtr,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)">
            <inheritdoc cref = "M:PInvoke.Kernel32.TryGetErrorMessage(PInvoke.Kernel32.FormatMessageFlags,System.Void*,System.Int32,System.Int32,System.Text.StringBuilder,System.IntPtr[],System.String@)"/>
        </member>
        <member name="T:PInvoke.Kernel32Extensions">
            <summary>
            Extension methods available for and from the Kernel32 library.
            </summary>
        </member>
        <member name="F:PInvoke.Kernel32Extensions.MaxAllowedBufferSize">
            <summary>
            The maximum memory we are willing to allocate for the exception message.
            </summary>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.GetMessage(PInvoke.Win32ErrorCode)">
            <summary>
            Gets the text associated with a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
            <param name="error">The error code.</param>
            <returns>The error message. Or <c>null</c> if no message could be found.</returns>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.Win32ErrorCode)">
            <summary>
            Throws an exception when an error occurs.
            </summary>
            <param name="errorCode">The result of the P/Invoke call.</param>
            <exception cref="T:PInvoke.Win32Exception">If <paramref name="errorCode"/> is not <see cref="F:PInvoke.Win32ErrorCode.ERROR_SUCCESS"/>.</exception>
        </member>
        <member name="M:PInvoke.Kernel32Extensions.ThrowOnError(PInvoke.NTSTATUS)">
            <summary>
            Throws an exception if a P/Invoke failed.
            </summary>
            <param name="status">The result of the P/Invoke call.</param>
        </member>
        <member name="T:PInvoke.NTStatusException">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
        </member>
        <member name="M:PInvoke.NTStatusException.#ctor(PInvoke.NTSTATUS,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.NTStatusException"/> class.
            </summary>
            <param name="statusCode">The status code identifying the error.</param>
            <param name="message">The exception message (which may be null to use the default).</param>
            <param name="inner">The inner exception.</param>
        </member>
        <member name="P:PInvoke.NTStatusException.NativeErrorCode">
            <summary>
            Gets the <see cref="T:PInvoke.NTSTATUS"/> code that identifies the error condition.
            </summary>
        </member>
        <member name="M:PInvoke.NTStatusException.GetMessage(PInvoke.NTSTATUS)">
            <summary>
            Gets the message associated with the given <see cref="T:PInvoke.NTSTATUS"/>.
            </summary>
            <param name="status">The <see cref="T:PInvoke.NTSTATUS"/> for the error.</param>
            <returns>The description of the error.</returns>
        </member>
        <member name="T:PInvoke.Win32Exception">
            <summary>
            An exception thrown for a failure described by a <see cref="T:PInvoke.Win32ErrorCode"/>.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
        </member>
        <member name="M:PInvoke.Win32Exception.#ctor(PInvoke.Win32ErrorCode,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:PInvoke.Win32Exception"/> class.
            </summary>
            <param name="error">The Win32 error code associated with this exception.</param>
            <param name="message">The message for this exception.</param>
        </member>
        <member name="P:PInvoke.Win32Exception.NativeErrorCode">
            <summary>
            Gets the Win32 error code associated with this exception.
            </summary>
            <devremarks>
            We must define this so that our own assembly on desktop is not a subset
            of what portable offers (lest runtime errors in our users occur).
            </devremarks>
        </member>
    </members>
</doc>
